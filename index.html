<html>
<head>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/codemirror/codemirror.css">
	<link rel="stylesheet" href="assets/app/site.css">
	<meta charset="UTF-8">
	<title>Javascript 函数式编程</title>
	<script type="text/javascript">
		// Adds the implementation for Array.prototype.concatAll()
		function defineConcatAll() {
			Array.prototype.concatAll = function () {
				var results = [];

				this.forEach(function(subArray) {
					results.push.apply(results, subArray);
				});

				return results;
			};
		}

		/**
		 * Add the implementation for Array.prototype.concatMap()
		 */
		function defineConcatMap() {
			Array.prototype.concatMap = function(fnc) {
				return this.
					map(function (e) {
						return fnc(e);
					}).
					// apply the concatAll function to flatten the two-dimensional array
					concatAll();
			};
		}

		/**
		 * This function will be executed at the begining of each verifier function
		 */
		function preVerifierHook() {
			// Add helpers to prevent 'undefined is not a function' like errors
			defineConcatAll();
			defineConcatMap();
		}
	</script>
</head>
<body>
<div class="content">
	<div class="grab-answers">
		<p>这是一套附带练习的交互式教程，你可以直接在浏览器中完成。<b>如果你只是想看到教程内容，点击下面的按钮</b>:</p>
		<button class="green-button show-answers">显示所有答案</button>
	</div>
	<h1 class="center">Javascript 函数式编程</h1>

	<p>这是一套用于学习使用微软 Reactive Extensions(Rx) Javascript 库的交互式学习教程。那为什么标题要叫做“Javascript函数式编程”呢？因为学习 Rx 的关键，就是要训练自己去使用函数式的编程方法，进行各种集合操作。函数式编程可以让开发者把常见的集合操作，抽象成一个个可重用的，可组合的代码块。你会惊讶的发现，绝大部分集合操作都可以用下面这<b>五个简单的函数</b>来实现(有些函数是Javascript原生自带的，有些包含在<a href="https://github.com/Reactive-Extensions/RxJS">RxJS library</a>里面）：
	</p>
	<ol>
		<li>map</li>
		<li>filter</li>
		<li>concatAll</li>
		<li>reduce</li>
		<li>zip</li>
	</ol>

	<p>我向你打包票，如果你掌握了这五个函数，你的代码会变得更精简，更有表达能力，而且更易于维护。而且，现在看起来可能不是很明显，但是实际上这五个函数式简化异步编程的关键。当你完成了这个教程之后，你就也掌握了必要的方法，可以做到避免竞态，传播和处理异步错误，处理串行的事件和 AJAX 请求等等。一句话，<b>这五个函数可能是你这辈子学到的所有函数中最强大，最灵活，最有用的</b>。
	</p>

	<h2>完成交互式练习</h2>

	<p>这个教程不仅仅是一个教程，它包含了<b>一系列的交互式练习，你只需要浏览器就可以完成。</b>完成练习的步骤很简单，只需要编辑代码，然后点击“运行”，如果代码可以工作，新的练习就会出现在下面，反之则会弹出错误提示。
	</p>
	<p><b>提示：</b>使用 "F4" 键可以打开编辑器的全屏模式</p>

	<p>这个教程可能存在 bug，如果你碰到了什么诡异的情况，或者你觉得已经输入了正确答案但是还是不能继续向下进行，就刷新一下浏览器试试。如果你使用的是现代浏览器（你都来到这里了，我相信你肯定不是用的IE6），练习的状态会被保存到本地。如果你需要的话，可以<a href="javascript:localStorage.newState = ''; document.location.reload();">重启这个教程.</a></p>

	<p>这个教程托管在
		<a href="https://github.com/ReactiveX/learnrx">Github</a>上, 处于一个正在逐渐被完善的阶段，如果你想添加新的练习，完善已有练习的问题描述，或者解决某个bug，都可以<a href="https://github.com/ReactiveX/learnrx/fork">fork</a>这个项目，然后发送 pull request。我们会试着把用户贡献的问题融合到已有的教程当中。
	</p>
	<div class="grab-answers">
		<p>你的答案会被存储到 local storage 当中. 如果你想把答案转移到另外的位置，使用下面的按钮进行操作:</p>
		<button class="green-button get-answer">把答案导出为 JSON</button>
		<button class="blue-button set-answer">导入 JSON 答案</button>
	</div>

	<h2>操作数组</h2>

	<p>在 Javascript 中，数组是唯一的集合类型，几乎写任何程序都需要用到数组。接下来我们要把上面提到的五个函数，加入到数组类型，让数组类型变得更加强大易用。实际上，Javascript 的数组类型已经自带了 map，filter 和 reduce 这三个函数了！不过我们还是要把他们重新实现一遍，作为练习的一部分。</p>

	<p>下面教程的过程是这样的，首先我们使用你在学校学过的方法（或者在别人代码中看到的方法）解决问题，也就是使用循环和赋值语句，把一个集合转换为另一个集合。然后我们实现上面提到的五个函数中的某一个，接下来使用这个函数<i>在不使用循环的情况下</i>解决相同的问题。当你把五个函数全部掌握之后，你会学习如何把他们结合起来，在不需要太多的代码的情况下，解决更加复杂的问题。</p>

	<h3>遍历数组</h3>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson" style="visibility: visible">
		<h4>练习 1: 打印数组中所有的名字</h4>
		<textarea class="code" rows="8" cols="80">
			function(console) {
				var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"],
					counter;

				for(counter = 0; counter < names.length; counter++) {
					console.log(names[counter]);
				}
			}
		</textarea>
		<button class="go">运行</button>
		<span class="aside">&lt;- 点这里来执行你的代码，如果结果正确，就可以继续下一个练习</span>

		<div class="output"></div>

		<pre class="verifier">
			// Traverse array with for loop
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")");
				var items = [];
				var got;
				var expected = '["Ben","Brian","Jafar","Matt","Priya"]';
				fun({
					log:function(name) {
						items.push(name);
						console.log(name);
					}
				});

				got = JSON.stringify(items.sort());
				if(got === expected) {
					return "成功!"
				}
				else {
					showLessonErrorMessage(expected, got, '注意：输出顺序没有关系');
				}
			}
		</pre>
		<pre class="answer">
			function(console) {
				var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"],
					counter;

				for(counter = 0; counter < names.length; counter++) {
					console.log(names[counter]);
				}
			}
		</pre>
		<p class="post">思考这个问题： <b>我们需要确定数组打印的<i>顺序</i>吗？</b>如果不需要，那么为什么需要循环呢？</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 2: 使用 forEach 打印数组中所有的名字</h4>
		<p>我们使用 forEach 函数重做上面的练习。</p>

		<textarea class="code" rows="8" cols="80">
			function(console) {
				var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"];

				names.forEach(function(name) {
					console.log(name);
				});
			}
		</textarea>
		<button class="go">运行</button>

		<div class="output"></div>

		<pre class="verifier">
			// Traverse array with foreach
			function(str) {
				preVerifierHook();
				if (str.indexOf(".forEach") === -1) {
					return "You have to use forEach!"
				}
				var fun = eval("(" + str + ")");
				var items =[];
				fun({
					log:function(name) {
						items.push(name);
						console.log(name);
					}
				});
				if(JSON.stringify(items.sort()) === '["Ben","Brian","Jafar","Matt","Priya"]') {
					return "Success!"
				}
				else {
					throw 'console.log 没有输出下面这些值: "Ben","Brian","Jafar","Matt","Priya" (注意：顺序没有关系)'
				}
			}
		</pre>

    	<pre class="answer">
			function(console) {
				var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"];

				names.forEach(function(name) {
					console.log(name);
				});
			}
    	</pre>
		<div class="post">
			<p>
				注意到一点，forEach 允许我们指明我们想要使用数组中的元素做些<i>什么</i>, 但是隐藏了数组是<i>怎么样</i>被遍历的细节.
			</p>
			<h3>投影数组</h3>
			<p>对某个值执行一个函数，以得到新的值，这种操作叫做<i>投影</i>。为了把一个数组投影成另一个数组，我们对数组中的每个元素都执行一个投影函数，然后把所有的结果收集起来，组成新的数组。
			</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 3: 使用 forEach 函数把一个包含 video 信息的数组投影成包含 {id,title} 对的新数组</h4>

		<p>对于每一个 video, 添加一个 {id, title} 对到 videoAndTitlePairs 数组。</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var newReleases = [
					{
						"id": 70111470,
						"title": "Die Hard",
						"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [4.0],
						"bookmark": []
					},
					{
						"id": 654356453,
						"title": "Bad Boys",
						"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [5.0],
						"bookmark": [{ id:432534, time:65876586 }]
					},
					{
						"id": 65432445,
						"title": "The Chamber",
						"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [4.0],
						"bookmark": []
					},
					{
						"id": 675465,
						"title": "Fracture",
						"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [5.0],
						"bookmark": [{ id:432534, time:65876586 }]
					}
				],
				videoAndTitlePairs = [];

				// ------------ 在这里写下答案 -----------------------------------
				// 使用 forEach 函数从 video 中拿到 {id, title}，使用 push() 方法把
				// 结果放到 videoAndTitlePairs 数组中。
				// 例如 videoAndTitlePairs.push(newItem);
				// ------------ 在这里写下答案 -----------------------------------


				return videoAndTitlePairs;
			}
		</textarea>

		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>

		<div class="output"></div>

		<pre class="verifier">
			// Projection with with forEach
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videoAndTitlePairs = fun(),
					expected = '[{\"id\":675465,\"title\":\"Fracture\"},{\"id\":65432445,\"title\":\"The Chamber\"},{\"id\":70111470,\"title\":\"Die Hard\"},{\"id\":654356453,\"title\":\"Bad Boys\"}]';

				// Sorting by video id
				videoAndTitlePairs = videoAndTitlePairs.sortBy(function(video) { return video.id });
				if (JSON.stringify(videoAndTitlePairs) === expected) {
					return true;
				}
				else {
					showLessonErrorMessage(expected, JSON.stringify(videoAndTitlePairs));
				}
			}
    	</pre>
        <pre class="answer">
			function() {
				var newReleases = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [4.0],
							"bookmark": []
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [5.0],
							"bookmark": [{ id:432534, time:65876586 }]
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [4.0],
							"bookmark": []
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [5.0],
							"bookmark": [{ id:432534, time:65876586 }]
						}
					],
					videoAndTitlePairs = [];

				newReleases.forEach(function(video) {
					videoAndTitlePairs.push({id:video.id, title: video.title});
				});

				return videoAndTitlePairs;
			}
		</pre>
		<div class="post">
			<p>所有的数组投影都需要完成下面两个操作</p>
			<ol>
				<li>遍历源数组</li>
				<li>把每个元素投影之后的结果添加到新数组</li>
			</ol>
			<p>既然如此，我们为什么不直接把<i>怎么样</i>执行这些操作的细节隐藏起来呢？</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 4: 实现 map()</h4>

		<p>为了让投影操作变得更简单，我们给数组类型添加一个<b>map()</b>方法。Map 函数接受一个投影函数作为参数，对源数组的每个对象都应用这个函数，然后返回投影后的数组。
		</p>

		<textarea class="code" rows="20" cols="80">
			Array.prototype.map = function(projectionFunction) {
				var results = [];
				this.forEach(function(itemInArray) {

					// ------------ 在这里写下答案 ----------------------------
					// 对数组中的每一个元素使用 projectionFunction 方法，并把结果放到
					// 一个数组里面。
					// 注意: 你可以使用 push() 方法把元素放到数组中。
					// ------------ 在这里写下答案 ----------------------------

				});

				return results;
			};

			// JSON.stringify([1,2,3].map(function(x) { return x + 1; })) === '[2,3,4]'
		</textarea>

		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>

		<div class="output"></div>

		<pre class="verifier">
			// Implement map()
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					arr = [1,2,3],
					result;

				result = arr.map(function(x) { return x + 1});

				if (JSON.stringify(arr) !== "[1,2,3]") {
					throw "喔! 你改变了源数组的值。Map 不应该改变输入数组的值，它应该对输入数组的每个元素执行投影函数之后，返回一个新的数组"
				}
				else if(JSON.stringify(result) !== '[2,3,4]') {
					throw '[1,2,3].map(function(x) { return x + 1}) 结果应该为 [2,3,4].'
				}
			}
		</pre>
		<pre class="answer">
			Array.prototype.map = function(projectionFunction) {
				var results = [];
				this.forEach(function(itemInArray) {
					results.push(projectionFunction(itemInArray));
				});

				return results;
			};

			// JSON.stringify([1,2,3].map(function(x) { return x + 1; })) === '[2,3,4]'
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 5: 使用 map() 把一个 videos 数组投影成 {id,title} 对数组</h4>

		<p>我们来重复上面的收集 {id, title} 对得到一个新数组的练习，<b>这次使用 map 函数来完成</b>。
		</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var newReleases = [
					{
						"id": 70111470,
						"title": "Die Hard",
						"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [4.0],
						"bookmark": []
					},
					{
						"id": 654356453,
						"title": "Bad Boys",
						"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [5.0],
						"bookmark": [{ id:432534, time:65876586 }]
					},
					{
						"id": 65432445,
						"title": "The Chamber",
						"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [4.0],
						"bookmark": []
					},
					{
						"id": 675465,
						"title": "Fracture",
						"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [5.0],
						"bookmark": [{ id:432534, time:65876586 }]
					}
				];

				// ------------ 在这里写下答案 -----------------------------------
				// 使用 map 方法拿到每个 video 当中的 {id, title}。
				return newReleases.map // 完成这个语句。
				// ------------ 在这里写下答案 -----------------------------------

			}
		</textarea>

		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Projection with map
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videoAndTitlePairs = fun(),
					expected = '[{\"id\":675465,\"title\":\"Fracture\"},{\"id\":65432445,\"title\":\"The Chamber\"},{\"id\":70111470,\"title\":\"Die Hard\"},{\"id\":654356453,\"title\":\"Bad Boys\"}]';

				// Sorting by video id
				videoAndTitlePairs = videoAndTitlePairs.sortBy(function(video) { return video.id });
				if (JSON.stringify(videoAndTitlePairs) === expected) {
					return true;
				}
				else {
					throw 'Expected: ' + expected;
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var newReleases = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [4.0],
							"bookmark": []
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [5.0],
							"bookmark": [{ id:432534, time:65876586 }]
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [4.0],
							"bookmark": []
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [5.0],
							"bookmark": [{ id:432534, time:65876586 }]
						}
					];

			  return newReleases.map(function(video) { return {id: video.id, title: video.title}; });
			}
		</pre>
		<div class="post">
			<p>注意到，map 允许我们指明我们想要对数组施加<i>什么</i>投影操作, 但是隐藏了这个操作是
				<i>怎么样</i>被执行的细节。
			</p>
			<h3>过滤数组</h3>
			<p>和投影类似，过滤（filter）数组也是很常见的操作。过滤一个数组是这样的过程，我们对数组中的每个元素都执行一个检查，然后把所有通过这个检查的元素收集成一个新的数组。
			</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 6: 使用 forEach() 收集那些评分（rating) 为 5.0 的 video</h4>

		<p>使用 forEach() 遍历 newReleases 数组, 如果一个 video 评分为 5.0, 就把它添加到 videos 数组.
		</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var newReleases = [
					{
						"id": 70111470,
						"title": "Die Hard",
						"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 4.0,
						"bookmark": []
					},
					{
						"id": 654356453,
						"title": "Bad Boys",
						"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 5.0,
						"bookmark": [{ id:432534, time:65876586 }]
					},
					{
						"id": 65432445,
						"title": "The Chamber",
						"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 4.0,
						"bookmark": []
					},
					{
						"id": 675465,
						"title": "Fracture",
						"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 5.0,
						"bookmark": [{ id:432534, time:65876586 }]
					}
				],
				videos = [];

				// ------------ 在这里写下答案 -----------------------------------
				// 使用 forEach 方法拿到所有 rating 为 5.0 的 video。
				// ------------ 在这里写下答案 -----------------------------------

				return videos;
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Filter with forEach
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					expected = '[{"id":675465,"title":"Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture.jpg","uri":"http://api.netflix.com/catalog/titles/movies/70111470","rating":5,"bookmark":[{"id":432534,"time":65876586}]},{"id":654356453,"title":"Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys.jpg","uri":"http://api.netflix.com/catalog/titles/movies/70111470","rating":5,"bookmark":[{"id":432534,"time":65876586}]}]';

				// Sorting by video id
				videos = videos.sortBy(function(v) { return v.id; });
				if (JSON.stringify(videos) === expected) {
					return true;
				}
				else {
					throw 'Expected: ' + expected;
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var newReleases = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
							"bookmark": []
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
							"bookmark": [{ id:432534, time:65876586 }]
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
							"bookmark": []
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
							"bookmark": [{ id:432534, time:65876586 }]
						}
					],
					videos = [];

				newReleases.forEach(function(video) {
					if (video.rating === 5.0) {
						videos.push(video);
					}
				});

				return videos;
			}
		</pre>

		<div class="post">
			<p>注意，和 map() 类似, <b>每个 filter() 操作也都要完成下面的操作</b>:</p>
			<ol>
				<li>遍历数组</li>
				<li>把通过测试的元素加入到新数组</li>
			</ol>
			<p>为什么我们不把这些实现细节也隐藏起来呢？</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 7: 实现 filter()</h4>

		<p>为了让过滤操作更简单, 我们给数组类型添加一个 filter() 函数。 filter() 接受一个<i>断言</i>作为参数。
			断言是这样一个函数： 它以数组中的一个元素作为参数，返回一个布尔值，表明这个元素应不应该被添加到新数组中。</p>

		<textarea class="code" rows="20" cols="80">
			Array.prototype.filter = function(predicateFunction) {
				var results = [];
				this.forEach(function(itemInArray) {
					// ------------ 在这里写下答案 ----------------------------
					// 对数组中的每个元素执行 predicateFunction 方法。如果返回为 true 就
					// 把它添加到结果数组中。
					// 注意: 你可以使用 push() 方法把元素放到数组中。
					// ------------ 在这里写下答案 ----------------------------
				});

				return results;
			};

			// JSON.stringify([1,2,3].filter(function(x) { return x > 2})) === "[3]"
		</textarea>

		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Implement filter()
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					arr = [1,2,3],
					result;

				result = arr.filter(function(x) { return x > 2});

				if (JSON.stringify(arr) !== "[1,2,3]") {
					throw "喔! 你改变了源数组的值。Filter 不应该改变输入数组的值，它应该对输入数组的每个元素执行投影函数之后，返回一个新的数组"
				}
				else if(JSON.stringify(result) !== '[3]') {
					throw '[1,2,3].filter(function(x) { return x > 2}) 结果应该为 [3].'
				}
			}
		</pre>
		<pre class="answer">
			Array.prototype.filter = function(predicateFunction) {
				var results = [];
				this.forEach(function(itemInArray) {
				  if (predicateFunction(itemInArray)) {
					results.push(itemInArray);
				  }
				});

				return results;
			};

			// JSON.stringify([1,2,3].filter(function(x) { return x > 2})) === "[3]"
		</pre>
		<p class="post">和 map() 类似, filter() 让我们选择想要<i>什么</i>数据，但是不要求我们指明<i>怎么样</i>去收集这些数据。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>使用链式调用来查询数据</h3>
		<h4>练习 8: 链式调用 filter 和 map，收集 video 当中 rating 为 0.5 的那些 video 的 id。</h4>
		<textarea class="code" rows="60" cols="80">
			function() {
				var newReleases = [
					{
						"id": 70111470,
						"title": "Die Hard",
						"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 4.0,
						"bookmark": []
					},
					{
						"id": 654356453,
						"title": "Bad Boys",
						"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 5.0,
						"bookmark": [{ id:432534, time:65876586 }]
					},
					{
						"id": 65432445,
						"title": "The Chamber",
						"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 4.0,
						"bookmark": []
					},
					{
						"id": 675465,
						"title": "Fracture",
						"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 5.0,
						"bookmark": [{ id:432534, time:65876586 }]
					}
				];

				// ------------ 在这里写下答案 -----------------------------------
				// 结合 filter 和 map 方法，拿到所有 rating 为 5.0 的 video 的 id。
				return newReleases // 完成这个语句
				// ------------ 在这里写下答案 -----------------------------------
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Filter with filter()
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videoids = fun(),
					expected = '[675465,654356453]';

				// Sorting by video id
				videoids = videoids.sortBy(function(v) { return v; });
				if (JSON.stringify(videoids) === expected) {
					return true;
				}
				else {
					throw 'Expected: ' + expected;
				}
			}
			</pre>
		<pre class="answer">
			function() {
				var newReleases = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
							"bookmark": []
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
							"bookmark": [{ id:432534, time:65876586 }]
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
							"bookmark": []
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
							"bookmark": [{ id:432534, time:65876586 }]
						}
					];

				// ------------   在这里写下答案   -----------------------------------
				// 结合 filter 和 map 方法，拿到所有 rating 为 5.0 的 video 的 id。


				return newReleases.
					filter(function(video) {
						return video.rating === 5.0;
					}).
					map(function(video) {
						return video.id;
					});
				// ------------   在这里写下答案  -----------------------------------
			}
		</pre>

		<p class="post">把 map() 和 filter() 结合在一起调用，让我们的代码变得富有表现力。 这些高层函数让我们表达我们想要
<i>什么</i>数据， 使得下层库在处理<i>怎么样</i>执行查询操作时可以有很大的灵活性。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>查询树</h3>
		<p>有时候，除了数组之外，我们还需要对树状数据结构进行查询。树带来了一个新的问题，因为我们需要首先把数展开成数组，然后才能使用 filter() 和 map() 操作。在这个部分的练习中，我们定义了 concatAll() 函数，结合它我们就可以使用 map() 和 filter 对树进行查询了。</p>

		<h4>练习 9: 把 movieLists 数组展开成包含 video 的 id 的数组</h4>

		<p>首先，我们使用两层嵌套的 forEach 循环，把二维数组 movieLists 中所有 video 的 id 收集起来。</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
					{
						name: "New Releases",
						videos: [
							{
								"id": 70111470,
								"title": "Die Hard",
								"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
								"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 654356453,
								"title": "Bad Boys",
								"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
								"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					},
					{
						name: "Dramas",
						videos: [
							{
								"id": 65432445,
								"title": "The Chamber",
								"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
								"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 675465,
								"title": "Fracture",
								"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
								"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					}
				],
				allVideoIdsInMovieLists = [];

				// ------------   在这里写下答案  -----------------------------------
				// 使用两层嵌套的 forEach 循环，把 movieLists 打平成一个 video id 的列表。
				// ------------   在这里写下答案  -----------------------------------

				return allVideoIdsInMovieLists;

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Use filter and map to collect video ids with rating of 5.0
			function(str) {
				var fun = eval("(" + str + ")"),
					videos = fun(),
					expected = '[675465,65432445,70111470,654356453]';

				videos = videos.sortBy(function(v) { return v });
				if (JSON.stringify(videos) !== expected) {
					throw "Expected " + expected;
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "Dramas",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					],
					allVideoIdsInMovieLists = [];

				movieLists.forEach(function(movieList) {
					movieList.videos.forEach(function(video) {
						allVideoIdsInMovieLists.push(video.id);
					});
				});

				return allVideoIdsInMovieLists;

			}
		</pre>

		<p class="post">用 forEach 来展开数组很简单，因为我们可以显式地把元素添加到新数组中。可惜，这恰恰就是我们想通过类似 map()，filter() 这种函数来封装起来的底层操作。我们能不能定义一个方法，使它足够抽象，允许我们指明想要展开一个树的<i>意图</i>，但是不需要指明<i>怎么样</i>完成这个操作？</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 10: 实现 concatAll()</h4>

		<p>我们给数组类型增加一个 concatAll() 方法。 concatAll() 会遍历数组中的每一个子数组，把它们的结果收集到一个新的，展开的数组当中。 注意<b> concatAll() 方法需要数组中的每一个元素也都是一个数组</b>。
		</p>

		<textarea class="code" rows="20" cols="80">
			Array.prototype.concatAll = function() {
				var results = [];
				this.forEach(function(subArray) {
					// ------------ 在这里写下答案 ----------------------------
					// 把每个子数组中元素添加到结果数组当中。
					// ------------ 在这里写下答案 ----------------------------
				});

				return results;
			};

			// JSON.stringify([ [1,2,3], [4,5,6], [7,8,9] ].concatAll()) === "[1,2,3,4,5,6,7,8,9]"
			// [1,2,3].concatAll(); // throws an error because this is a one-dimensional array
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Flatten movieLists into an array of video ids
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					arr = [[1,2,3],[4,5,6],[7,8,9]],
					result,
					expected = "[1,2,3,4,5,6,7,8,9]";

				result = arr.concatAll();
				result = result.sortBy(function(x) { return x; });
				if (JSON.stringify(result) !== expected) {
					throw 'Expected that [[1,2,3],[4,5,6],[7,8,9]].concatAll() would equal [1,2,3,4,5,6,7,8,9].'
				}
			}
		</pre>
		<pre class="answer">
			Array.prototype.concatAll = function() {
				var results = [];
				this.forEach(function(subArray) {
					results.push.apply(results, subArray);
				});

				return results;
			};

			// JSON.stringify([ [1,2,3], [4,5,6], [7,8,9] ].concatAll()) === "[1,2,3,4,5,6,7,8,9]"
			// [1,2,3].concatAll(); // throws an error because this is a one-dimensional array
		</pre>
		<p class="post">concatAll 函数非常简单，简单到你可能都不太会注意到它如何与 map() 结合起来，进行树的查询，我们来举一个例子。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 11: 使用 map() 和 concatAll() 对 movieLists 进行投影和展开，获取包含所有 video 的 id 的数组</h4>

		<p>提示: 使用两个嵌套的 map() 和一个 concatAll()。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "Dramas",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];

				// ------------  在这里写下答案  -----------------------------------
				// 使用 map 和 concatAll 把 movieLists 打平成 video id 的数组。
				// ------------  在这里写下答案  -----------------------------------

				return movieLists // 完成这个语句

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					expected = '[675465,65432445,70111470,654356453]';

				videos = videos.sortBy(function(v) { return v });
				if (JSON.stringify(videos) !== expected) {
					throw "Expected " + expected + "\n\nReceived " + JSON.stringify(videos);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "Dramas",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];

				// ------------  在这里写下答案  -----------------------------------
				// 使用 map 和 concatAll 把 movieLists 打平成 video id 的数组。

				return movieLists.
				  map(function(movieList) {
					return movieList.videos.map(function(video) {
						return video.id;
					  });
				  }).
				  concatAll();

				// ------------  在这里写下答案  -----------------------------------
			}
		</pre>

		<p class="post"><b>干得漂亮！</b> 掌握 map() 和 concatAll() 的结合使用对于高效率的函数式编程而言十分重要。你已经迈出了坚实的一步！我们来尝试一个更加复杂的例子。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 12: 获取每个 video 的 id， title 和 150x200 大小的 box art url</h4>

		<p>你已经成功地展开过一个两层深的树了，我们来试一下三层的。对于每个 video，我们不是只有一个 boxart url，而是有一组 boxart 对象，每个对象里包含了不同的大小和 url。你需要做这样一个查询，从 movieLists 中把每个 video 的 {id, title, boxart} 筛选出来，而且这次结果中的 boxart url 需要来自具有 150x200px 尺寸的 boxart 对象。试着使用 map()，concatAll() 和 filter() 解决这个问题。</p>
		<a name="indexers"></a>

		<p><b>还有一件事：你<u>不能</u>使用数组下标。</b>也就是说这样的写法是
			<span style="color:red">非法的</span>:</p>
			<pre>
				var itemInArray = movieLists<span style="color:red">[0]</span>;
			</pre>

		<p>更进一步的，<b>在接下来的所有练习中你都不能使用下标</b>，除非你是在实现开始提到的那五个函数中的某一个。这样做是有很大的好处的，具体的好处我们会在后面解释清楚。现在你只需要遵守这个规定，并且相信这样做的目的是好的就可以了 :-)</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
						{
							name: "Instant Queue",
							videos : [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "New Releases",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];


				// 使用一个或者多个 map，concatAll，filter 方法拿到一个有下列元素的数组
				// [
				//	 {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				//	 {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
				//	 {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
				//	 {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists // 完成这个语句

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output">
		</div>

		<pre class="verifier">
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					got,
					expected = JSON.stringify([
						{"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
						{"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
						{"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
					].sortBy(function(v) { return v.id }));

				if (str.indexOf('[0]') !== -1) {
					throw "你不能使用数组下标。你可能过早地创建了对象。与其使用数组下标来从数组中获取 boxart，试着使用 map() 方法在投影函数中创建新的对象";
				}

				videos = videos.sortBy(function(v) { return v.id });
				got = JSON.stringify(videos);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "Instant Queue",
							videos : [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "New Releases",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];


				// 使用一个或者多个 map，concatAll，filter 方法拿到一个有下列元素的数组
				// [
				//     {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				//     {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
				//     {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
				//     {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists.
				  map(function(movieList) {
					return movieList.videos.
					  map(function(video) {
						return video.boxarts.
						  filter(function(boxart) {
							return boxart.width === 150;
						  }).
						  map(function(boxart) {
							return {id: video.id, title: video.title, boxart: boxart.url};
						  });
					  }).
					  concatAll();
				  }).
				  concatAll();

			}
		</pre>
		<p class="post">精彩！现在你已经学会了使用 concatAll()， map() 以及 filter() 进行树的查询。
			注意到<b>map() 和 concatAll() 经常会一起使用。</b>我们来加入一个小的助手函数来处理这种场景。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 13: 实现 concatMap()</h4>

		<p>几乎每次我们需要展开一个树的时候，都会链接使用 map() 和 concatAll()。有些时候，如果我们需要处理的树有好几层深，我们就需要在代码中重复好几次这种写法。为了让代码更简单，我们加入 concatMap 方法，它就是一个 map 操作, 然后紧接一个 concatAll。</p>
		<textarea class="code" rows="20" cols="80">
			Array.prototype.concatMap = function(projectionFunctionThatReturnsArray) {
				return this.
					map(function(item) {
						// ------------  在这里写下答案  -----------------------------------
						// 对每个元素都执行投影函数，这个函数会返回一个子数组，整个操作会产生一个二维数组
						// ------------  在这里写下答案  -----------------------------------
					}).
					// apply the concatAll function to flatten the two-dimensional array
					concatAll();
			};

			/*
				var spanishFrenchEnglishWords = [ ["cero","rien","zero"], ["uno","un","one"], ["dos","deux","two"] ];
				// collect all the words for each number, in every language, in a single, flat list
				var allWords = [0,1,2].
					concatMap(function(index) {
						return spanishFrenchEnglishWords[index];
					});

				return JSON.stringify(allWords) === '["cero","rien","zero","uno","un","one","dos","deux","two"]';
			*/
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Implement concatAll
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					spanishFrenchEnglishWords = [ ["cero","rien","zero"], ["uno","un","one"], ["dos","deux","two"] ],
					allWords = [0,1,2],
					result,
					expected = '["cero","rien","zero","uno","un","one","dos","deux","two"]';


				var allWords = [0,1,2].
					concatMap(function(index) {
						return spanishFrenchEnglishWords[index];
					});

				if (JSON.stringify(allWords) !== expected) {
					throw "Expected " + expected;
				}
			}
		</pre>
		<pre class="answer">
			Array.prototype.concatMap = function(projectionFunctionThatReturnsArray) {
				return this.
					map(function(item) {
						return projectionFunctionThatReturnsArray(item);
					}).
					// apply the concatAll function to flatten the two-dimensional array
					concatAll();
			};

			/*
				var spanishFrenchEnglishWords = [ ["cero","rien","zero"], ["uno","un","one"], ["dos","deux","two"] ];
				// collect all the words for each number, in every language, in a single, flat list
				var allWords = [0,1,2].
					concatMap(function(index) {
						return spanishFrenchEnglishWords[index];
					});

				return JSON.stringify(allWords) === '["cero","rien","zero","uno","un","one","dos","deux","two"]';
			*/
		</pre>


		<p class="post">从现在起，在展开树的时候不需要再使用 map().concatAll()，我们可以直接使用 concatMap 函数。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 14: 使用 concatMap() 去检索每一个视频的 id，title，和 boxarts url。</h4>

		<p>让我们再来做一下刚刚做过的那个练习。这一次我们将用 concatMap() 来替换 map().concatAll() 来简化代码。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
						{
							name: "Instant Queue",
							videos : [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "New Releases",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];


				// 使用一个或者多个 concatMap, map，filter 方法拿到一个有下列元素的数组
				// [
				//	 {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				//	 {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
				//	 {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
				//	 {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists // Complete this expression!

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					got,
					expected = JSON.stringify([
						{"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
						{"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
						{"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
					].sortBy(function(v) { return v.id }));

				videos = videos.sortBy(function(v) { return v.id });
				got = JSON.stringify(videos);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "Instant Queue",
							videos : [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "New Releases",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];


				// 使用一个或者多个 concatMap, map，filter 方法拿到一个有下列元素的数组
				// [
				//     {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				//     {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
				//     {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
				//     {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists.concatMap(function(movieList) {
					return movieList.videos.concatMap(function(video) {
						return video.boxarts.
							filter(function(boxart) {
								return boxart.width === 150;
						  	}).
						  	map(function(boxart) {
								return {id: video.id, title: video.title, boxart: boxart.url};
							});
					  });
				  });
			}
		</pre>
		<p class="post">将最后一个运算变为 map，是一种访问若干嵌套的 concatMap 运算的很常见的方式。你可以把这种方式当做一个嵌套的 forEach 的函数式版本。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>缩减数组</h3>
		<p>有时我们需要<i>同时</i>对数组中很多项进行操作。举例，我们需要找到数组中的最大整型值。我们不能使用 filter()，因为 filter() 每次只对一项进行检查。为了找到这个最大整型值，我们需要互相比较数组中的每一项。
		</p>
		<p>先<i>假设</i>某一项是最大值（可能是第一项)，然后再把它和数组中其余所有项进行对比。每一次我们找到一个比假想值大的数时，就把这个假想值替换为我们找到的这个值，直到我们遍历完整个数组。</p>
		<p>如果我们用闭包来替换特定大小的比较，我们需要写一个函数来遍历数组。每一步我们的函数将在当前的值和最后的值运用闭包 ，下一次就将结果作为最后的值。最后我们只剩下一个值。这个过程被称为<i>缩减</i>，因为我们将很多的值变为了一个值。</p>

		<h4>练习 15: 使用 forEach 找到最大的 box art</h4>

		<p>在这个例子中我们将使用 forEach 找到最大的 box art。我们每次检查一个新的 boxart 都会更新一下目前找到的最大值 maximumSize。
			如果当前 boxart 的大小小于这个值，就丢弃它，如果大于，就保留它。最后我们会得到一个拥有最大尺寸的 boxart。</p>
		<textarea class="code" rows="15" cols="80">
			function() {
				var boxarts = [
						{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
					],
					currentSize,
					maxSize = -1,
					largestBoxart;

				boxarts.forEach(function(boxart) {
					currentSize = boxart.width * boxart.height;
					if (currentSize > maxSize) {
						largestBoxart = boxart;
						maxSize = currentSize;
					}
				});

				return largestBoxart;
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Find largest box art
			function(str){
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					boxart = fun(),
					got = JSON.stringify(boxart),
					expected = JSON.stringify({ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" });

				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var boxarts = [
						{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
					],
					currentSize,
					maxSize = -1,
					largestBoxart;

				boxarts.forEach(function(boxart) {
					currentSize = boxart.width * boxart.height;
					if (currentSize > maxSize) {
						largestBoxart = boxart;
						maxSize = currentSize;
					}
				});

				return largestBoxart;
			}
		</pre>
		<p class="post">这个过程叫做缩减（reduction）。我们每次使用上次计算的结果，来计算当前的值。在这个例子中我们
			还是需要手动进行遍历操作。如果我们只需要声明我们想要做的操作，不就更好了吗？下面我们就来写这样一个助手函数用来对数组进行缩减操作。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 16: 实现 reduce()</h4>

		<p>和 map 类似，我们给 Array 类型增加一个 reduce 方法。</p>
		<textarea class="code" rows="40" cols="80">
			// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }); === [6];
			// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }, 10); === [16];

			Array.prototype.reduce = function(combiner, initialValue) {
				var counter,
					accumulatedValue;

				// 如果数组是空，直接返回
				if (this.length === 0) {
					return this;
				}
				else {
					// 如果用户没有提供初始值，使用数组当中的第一个元素。
					if (arguments.length === 1) {
						counter = 1;
						accumulatedValue = this[0];
					}
					else if (arguments.length >= 2) {
						counter = 0;
						accumulatedValue = initialValue;
					}
					else {
						throw "Invalid arguments.";
					}

					// 遍历整个数组，把当前元素和上一次计算的结果，传给 combiner 函数，直到遍历完整个
					// 数组，只剩下一个值。
					while(counter < this.length) {
						accumulatedValue = combiner(accumulatedValue, this[counter])
						counter++;
					}

					return [accumulatedValue];
				}
			};
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Implement reduce
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					numbers = [1,2,3],
					sum = numbers.reduce(function(acc,curr) { return acc + curr }),
					expected = JSON.stringify([6]),
					sum2 = numbers.reduce(function(acc,curr) { return acc + curr },10),
					expected2 = JSON.stringify([16]);

				if (JSON.stringify(sum) !== expected) {
					throw "Expected that [1,2,3].reduce(function(accumulated,current) { return accumulated + current; }) === [6]. Instead got " + JSON.stringify(sum);
				}
				if (JSON.stringify(sum2) !== expected2) {
					throw "Expected that [1,2,3].reduce(function(accumulated,current) { return accumulated + current; }, 10) === [16]. Instead got " + JSON.stringify(sum2);
				}
			}
		</pre>
		<pre class="answer">
			// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }); === [6];
			// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }, 10); === [16];

			Array.prototype.reduce = function(combiner, initialValue) {
				var counter,
					accumulatedValue;

				// 如果数组是空，直接返回
				if (this.length === 0) {
					return this;
				}
				else {
					// 如果用户没有提供初始值，使用数组当中的第一个元素。
					if (arguments.length === 1) {
						counter = 1;
						accumulatedValue = this[0];
					}
					else if (arguments.length >= 2) {
						counter = 0;
						accumulatedValue = initialValue;
					}
					else {
						throw "Invalid arguments.";
					}

					// 遍历整个数组，把当前元素和上一次计算的结果，传给 combiner 函数，直到遍历完整个
					// 数组，只剩下一个值。
					while(counter < this.length) {
						accumulatedValue = combiner(accumulatedValue, this[counter])
						counter++;
					}

					return [accumulatedValue];
					}
			};
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson"><h4>练习 17: 获取最大的 rating。</h4>

		<p>下面我们使用 reduce 方法找到一个 rating 数组当中的最大值。</p>
		<textarea class="code" rows="15" cols="80">
			function() {
				var ratings = [2,3,1,4,5];

				// 返回一个只有最大 rating 的数组。注意 reduce 总是返回一个只包含一个元素的数组。
				return ratings.
				reduce   // Complete this expression
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			 // Find largest rating
			function(str){
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					boxarts = fun(),
					got = JSON.stringify(boxarts),
					expected = JSON.stringify([5]);


				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var ratings = [2,3,1,4,5];

				// 返回一个只包含最大 rating 的数组。注意 reduce 总是返回一个只包含一个元素的数组。
				return ratings.
				  reduce(function(acc, curr) {
					if(acc > curr) {
					  return acc;
					}
					else {
					  return curr;
					}
				  });
			}
		</pre>
		<p class="post">干得漂亮。下面我们将试着把 reduce() 和其他函数结合起来构建更复杂的查询操作。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 18: 获取最大的 boxart 的 url</h4>

		<p>我们试一下结合使用 reduce() 和 map()，将多个 boxart 对象缩减成一个值：最大 boxart 的 url。</p>
		<textarea class="code" rows="15" cols="80">
			function() {
				var boxarts = [
						{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
					];

				// 返回一个只包含最大 boxart 的 URL 的数组。注意 reduce 总是返回一个只包含一个元素的数组。
				return boxarts.
					reduce   // Complete this expression
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Find largest box art with reduce
			function(str){
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					boxarts = fun(),
					got = JSON.stringify(boxarts),
					expected = JSON.stringify(["http://cdn-0.nflximg.com/images/2891/Fracture425.jpg"]);


				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var boxarts = [
						{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
					];

				// 返回一个只包含最大 boxart 的 URL 的数组。注意 reduce 总是返回一个只包含一个元素的数组。
				return boxarts.
				  reduce(function(acc,curr) {
					if (acc.width * acc.height > curr.width * curr.height) {
					  return acc;
					}
					else {
					  return curr;
					}
				  }).
				  map(function(boxart) {
					return boxart.url;
				  });
			}
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 19: 带有初始值的缩减 </h4>

		<p>有时候，我们想缩减一个数组，同时希望缩减后的值类型，不同于数组当中的元素值类型。
			举个例子，我们有一个 video 的数组，我们想通过缩减它来得到一个键是 video id，值是 video title 的 map。</p>

		<textarea id="q18" class="code" rows="15" cols="80">
			function() {
				var videos = [
					{
						"id": 65432445,
						"title": "The Chamber"
					},
					{
						"id": 675465,
						"title": "Fracture"
					},
					{
						"id": 70111470,
						"title": "Die Hard"
					},
					{
						"id": 654356453,
						"title": "Bad Boys"
					}
				];

				// Expecting this output...
				// [
				//	 {
				//		 "65432445": "The Chamber",
				//		 "675465": "Fracture",
				//		 "70111470": "Die Hard",
				//		 "654356453": "Bad Boys"
				//	 }
				// ]
				return videos.
					reduce(function(accumulatedMap, video) {

						// Object.create() makes a fast copy of the accumulatedMap by
						// creating a new object and setting the accumulatedMap to be the
						// new object's prototype.
						// Initially the new object is empty and has no members of its own,
						// except a pointer to the object on which it was based. If an
						// attempt to find a member on the new object fails, the new object
						// silently attempts to find the member on its prototype. This
						// process continues recursively, with each object checking its
						// prototype until the member is found or we reach the first object
						// we created.
						// If we set a member value on the new object, it is stored
						// directly on that object, leaving the prototype unchanged.
						// Object.create() is perfect for functional programming because it
						// makes creating a new object with a different member value almost
						// as cheap as changing the member on the original object!

						var copyOfAccumulatedMap = Object.create(accumulatedMap);

						// ----- 用 video id 做 key 把 video title 插入新的 map 中

						return copyOfAccumulatedMap;
					},
					// Use an empty map as the initial value instead of the first item in
					// the list.
					{});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Reducing with an initial value
			function(str){
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videoMap = fun()[0],
					expected = [
						{
							"65432445": "The Chamber",
							"675465": "Fracture",
							"70111470": "Die Hard",
							"654356453": "Bad Boys"
						}
					];

				if (!(videoMap["65432445"] === "The Chamber" && videoMap["675465"] === "Fracture" && videoMap["70111470"] === "Die Hard" && videoMap["654356453"] === "Bad Boys")) {
					throw "Expected " + JSON.stringify(expected);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var videos = [
					{
						"id": 65432445,
						"title": "The Chamber"
					},
					{
						"id": 675465,
						"title": "Fracture"
					},
					{
						"id": 70111470,
						"title": "Die Hard"
					},
					{
						"id": 654356453,
						"title": "Bad Boys"
					}
				];

				// Expecting this output...
				// [
				//     {
				//         "65432445": "The Chamber",
				//         "675465": "Fracture",
				//         "70111470": "Die Hard",
				//         "654356453": "Bad Boys"
				//     }
				// ]
				return videos.
					reduce(function(accumulatedMap, video) {

						// Object.create() makes a fast copy of the accumulatedMap by
						// creating a new object and setting the accumulatedMap to be the
						// new object's prototype.
						// Initially the new object is empty and has no members of its own,
						// except a pointer to the object on which it was based. If an
						// attempt to find a member on the new object fails, the new object
						// silently attempts to find the member on its prototype. This
						// process continues recursively, with each object checking its
						// prototype until the member is found or we reach the first object
						// we created.
						// If we set a member value on the new object, it is stored
						// directly on that object, leaving the prototype unchanged.
						// Object.create() is perfect for functional programming because it
						// makes creating a new object with a different member value almost
						// as cheap as changing the member on the original object!

						var copyOfAccumulatedMap = Object.create(accumulatedMap);

						copyOfAccumulatedMap[video.id] = video.title;

						return copyOfAccumulatedMap;
					},
					// Use an empty map as the initial value instead of the first item in
					// the list.
					{});
			}
		</pre>

		<p class="post">做的好。现在我们试着把 reduce 和其他函数结合起来构建更复杂的查询操作。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 20: 取出每个 vidode 的 id，title 以及<i>最小的</i> boxart 的 url。</h4>

		<p>这个练习是我们之前解决过的问题的一个变体。在之前的问题中，我们取出了 width 为 150px 的 boxart 的 url。
			这次我们使用 reduce() 替代 filter，取出<i>最小的</i> box art。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
					{
						name: "New Releases",
						videos: [
							{
								"id": 70111470,
								"title": "Die Hard",
								"boxarts": [
									{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 654356453,
								"title": "Bad Boys",
								"boxarts": [
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
									{ width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }

								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					},
					{
						name: "Thrillers",
						videos: [
							{
								"id": 65432445,
								"title": "The Chamber",
								"boxarts": [
									{ width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 675465,
								"title": "Fracture",
								"boxarts": [
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
									{ width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
									{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					}
				];


				// 使用一个或多个 concatMap， map，和 reduce 操作得到下面的数组（顺序无关）。
				// [
				//	 {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
				//	 {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
				//	 {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" },
				//	 {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists.
					concatMap(function(movieList) {

					})

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output">
		</div>
		<pre class="verifier">
			// Find the id, title, and smallest box art.
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					got,
					expected = JSON.stringify([
						{"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
						{"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
						{"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" },
						{"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
					].sortBy(function(v) { return v.id }));

				if (str.indexOf('[0]') !== -1){
					throw "You're not allowed to index into the array. You might be creating the object too early. Instead of using an indexer to get the boxart out of the array, try adding a call to map() and creating the object inside the projection function.";
				}
				videos = videos.sortBy(function(v) { return v.id });
				got = JSON.stringify(videos);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
					{
						name: "New Releases",
						videos: [
							{
								"id": 70111470,
								"title": "Die Hard",
								"boxarts": [
									{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 654356453,
								"title": "Bad Boys",
								"boxarts": [
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
									{ width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }

								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					},
					{
						name: "Thrillers",
						videos: [
							{
								"id": 65432445,
								"title": "The Chamber",
								"boxarts": [
									{ width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 675465,
								"title": "Fracture",
								"boxarts": [
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
									{ width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
									{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					}
				];


				// 使用一个或多个 concatMap， map，和 reduce 操作得到下面的数组（顺序无关）。
				// [
				//     {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
				//     {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
				//     {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" },
				//     {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists.concatMap(function(movieList) {
				  return movieList.videos.concatMap(function(video) {
				    return video.boxarts.
					  reduce(function(acc,curr) {
						if (acc.width * acc.height < curr.width * curr.height) {
						  return acc;
						}
						else {
						  return curr;
						}
					  }).
					  map(function(boxart) {
						return {id: video.id, title: video.title, boxart: boxart.url};
					  });
				  });
				});

			}
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>合并数组</h3>
		<p>有时候我们需要把两个数组合并(zip)，分别从两个数组当中拿出一个元素，组成一个元素对的数组。把数组想象成拉链，每个数组是拉链的一边，
			元素是拉链的牙，这样你可以更好地理解合并数组是什么样的操作。</p>
		<h4>练习 21: 按数组下标合并 videos 和 bookmarks</h4>

		<p>使用一个 for 循环，同时遍历 videos 和 bookmarks 数组。对每一个 video 和 bookmarkl 创建一个 {videoId, bookmarkId} 对，
			并把它加入 videoIdAndBookmarkIdPairs 数组中。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var videos = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						}
					],
					bookmarks = [
						{id: 470, time: 23432},
						{id: 453, time: 234324},
						{id: 445, time: 987834}
					],
				counter,
				videoIdAndBookmarkIdPairs = [];

				for(var counter = 0; counter < Math.min(videos.length, bookmarks.length); counter++) {
					// 创建一个 {videoId, bookmarkId} 对并把它添加到 videoIdAndBookmarkIdPairs。
				}

				return videoIdAndBookmarkIdPairs;
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Zip imperatively
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					pairs = fun(),
					got,
					expected = '[{"videoId":65432445,"bookmarkId":445},{"videoId":70111470,"bookmarkId":470},{"videoId":654356453,"bookmarkId":453}]';

				pairs = pairs.sortBy(function(v) { return v.videoId });
				got = JSON.stringify(pairs);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var videos = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						}
					],
					bookmarks = [
						{id: 470, time: 23432},
						{id: 453, time: 234324},
						{id: 445, time: 987834}
					],
				counter,
				videoIdAndBookmarkIdPairs = [];

				for(var counter = 0; counter < Math.min(videos.length, bookmarks.length); counter++) {
				  videoIdAndBookmarkIdPairs.push({videoId: videos[counter].id, bookmarkId: bookmarks[counter].id});
				}

				return videoIdAndBookmarkIdPairs;
			}
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 22: 实现 zip</h4>

		<p>我们来给 Array 类型添加一个静态的 zip() 方法。zip 方法接受一个 combiner 函数作为参数，同时遍历两个数组，并且在两边数组的对应元素执行
			combiner 函数。zip 方法需要元素才能调用 combiner，因此 zip 返回的数组长度是两个数组当中最小的那个的长度。
		<p>
		<textarea class="code" rows="40" cols="80">
			// JSON.stringify(Array.zip([1,2,3],[4,5,6], function(left, right) { return left + right })) === '[5,7,9]'

			Array.zip = function(left, right, combinerFunction) {
				var counter,
					results = [];

				for(counter = 0; counter < Math.min(left.length, right.length); counter++) {
					// 对两个数组中的对应元素执行 combinerFunction 方法。
				}

				return results;
			};
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Implement zip
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					left = [1,2,3],
					right = [4,5,6],
					sum = Array.zip(left, right, function(left, right){ return left + right; }),
					expected = '[5,7,9]';

				if (JSON.stringify(sum) !== expected) {
					showLessonErrorMessage(expected, JSON.stringify(sum));
				}
			}
		</pre>
		<pre class="answer">
			// JSON.stringify(Array.zip([1,2,3],[4,5,6], function(left, right) { return left + right })) === '[5,7,9]'

			Array.zip = function(left, right, combinerFunction) {
				var counter,
					results = [];

				for(counter = 0; counter < Math.min(left.length, right.length); counter++) {
					results.push(combinerFunction(left[counter],right[counter]));
				}

				return results;
			};
        </pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 23: Combine videos and bookmarks by index</h4>

		<p>Let's repeat exercise 21, but this time lets use your new zip() function. For each video and bookmark pair,
			create a {videoId, bookmarkId} pair.</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var videos = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						}
					],
					bookmarks = [
						{id: 470, time: 23432},
						{id: 453, time: 234324},
						{id: 445, time: 987834}
					];

				return Array.
					zip( //... finish this expression
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Combine videos and bookmarks
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					pairs = fun(),
					got,
					expected = '[{"videoId":65432445,"bookmarkId":445},{"videoId":70111470,"bookmarkId":470},{"videoId":654356453,"bookmarkId":453}]';

				pairs = pairs.sortBy(function(v) { return v.videoId });
				got = JSON.stringify(pairs);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var videos = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						}
					],
					bookmarks = [
						{id: 470, time: 23432},
						{id: 453, time: 234324},
						{id: 445, time: 987834}
					];

				return Array.
					zip(
					  videos,
					  bookmarks,
					  function(video, bookmark) {
						return {videoId: video.id, bookmarkId: bookmark.id};
					  });
			}
        </pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 24: Retrieve each video's id, title, middle interesting moment time, and <i>smallest</i> box art url.</h4>

		<p>This is a variation of the problem we solved earlier. This time each video has an interesting moments collection,
			each representing a time during which a screenshot is interesting or representative of the title as a whole. Notice
			that both the boxarts and interestingMoments arrays are located at the same depth in the tree. Retrieve the time of
			the middle interesting moment and the smallest box art url <i>simultaneously</i> with zip(). Return an {id, title,
			time, url} object for each video.</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"interestingMoments": [
										{ type: "End", time:213432 },
										{ type: "Start", time: 64534 },
										{ type: "Middle", time: 323133}
									]
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"interestingMoments": [
										{ type: "End", time:54654754 },
										{ type: "Start", time: 43524243 },
										{ type: "Middle", time: 6575665}
									]
								}
							]
						},
						{
							name: "Instant Queue",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"interestingMoments": [
										{ type: "End", time:132423 },
										{ type: "Start", time: 54637425 },
										{ type: "Middle", time: 3452343}
									]
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"interestingMoments": [
										{ type: "End", time:45632456 },
										{ type: "Start", time: 234534 },
										{ type: "Middle", time: 3453434}
									]
								}
							]
						}
					];

				//------------ COMPLETE THIS EXPRESSION --------------
				return movieLists.
					concatMap(function(movieList) {

					});

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<pre class="verifier">
			// Find id, title, smallest box art, and bookmark id
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					got,
					expected = '[{"id":675465,"title":"Fracture","time":3453434,"url":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg"},{"id":65432445,"title":"The Chamber","time":3452343,"url":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg"},{"id":70111470,"title":"Die Hard","time":323133,"url":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg"},{"id":654356453,"title":"Bad Boys","time":6575665,"url":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg"}]';

				videos = videos.sortBy(function(v) { return v.id });
				got = JSON.stringify(videos);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"interestingMoments": [
										{ type: "End", time:213432 },
										{ type: "Start", time: 64534 },
										{ type: "Middle", time: 323133}
									]
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"interestingMoments": [
										{ type: "End", time:54654754 },
										{ type: "Start", time: 43524243 },
										{ type: "Middle", time: 6575665}
									]
								}
							]
						},
						{
							name: "Instant Queue",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"interestingMoments": [
										{ type: "End", time:132423 },
										{ type: "Start", time: 54637425 },
										{ type: "Middle", time: 3452343}
									]
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"interestingMoments": [
										{ type: "End", time:45632456 },
										{ type: "Start", time: 234534 },
										{ type: "Middle", time: 3453434}
									]
								}
							]
						}
					];

				//------------ COMPLETE THIS EXPRESSION --------------
				return movieLists.concatMap(function(movieList) {
					return movieList.videos.concatMap(function(video) {
						return Array.zip(
							video.boxarts.reduce(function(acc,curr) {
								if (acc.width * acc.height < curr.width * curr.height) {
							  	  	return acc;
								}
								else {
							  		return curr;
								}
						  	}),
							video.interestingMoments.filter(function(interestingMoment) {
								return interestingMoment.type === "Middle";
							}),
						  	function(boxart, interestingMoment) {
								return {id: video.id, title: video.title, time: interestingMoment.time, url: boxart.url};
						  	});
					});
				});
			}
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>Powerful Queries</h3>

		<p>Now that we've learned the five operators let's flex our muscles and write some powerful queries.</p>

		<h4>Exercise 25: Converting from Arrays to Trees</h4>

		<p>When information is organized in a tree like a JSON expression, relationships point from parent to child. In
			relational systems like databases, relationships point from children to their parents. Both ways of organizing
			information are equivalent, and depending on the circumstances, we might get data organized in one way or
			another. It may surprise you to learn that you can use the 5 query functions you already know to easily convert
			between these representations. In other words, <b>not only can you query arrays from trees, you can query trees
				from arrays</b>.</p>

		<p>We have 2 arrays each containing lists, and videos respectively. Each video has a listId field indicating its
			parent list. We want to build an array of list objects, each with a name and a videos array. The videos array
			will contain the video's id and title. In other words we want to build the following structure:</p>
        <pre>
			[
				{
					"name": "New Releases",
					"videos": [
						{
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"id": 675465,
							"title": "Fracture"
						}
					]
				},
				{
					"name": "Thrillers",
					"videos": [
						{
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"id": 654356453,
							"title": "Bad Boys"
						}
					]
				}
			]
        </pre>
		<p><b>Note: please make sure when creating objects (both lists and videos) that you add properties in the same order
			as above. This doesn't impact the correctness of your code, but the verifier expects properties to be created in
			this order.</b></p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var lists = [
						{
							"id": 5434364,
							"name": "New Releases"
						},
						{
							"id": 65456475,
							"name": "Thrillers"
						}
					],
					videos = [
						{
							"listId": 5434364,
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"listId": 5434364,
							"id": 675465,
							"title": "Fracture"
						},
						{
							"listId": 65456475,
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"listId": 65456475,
							"id": 654356453,
							"title": "Bad Boys"
						}
					];

				return lists. // complete this expression
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
        <pre class="verifier">
			// Combine videos and bookmarks
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					pairs = fun(),
					got,
					expected = '[{"name":"New Releases","videos":[{"id":65432445,"title":"The Chamber"},{"id":675465,"title":"Fracture"}]},{"name":"Thrillers","videos":[{"id":70111470,"title":"Die Hard"},{"id":654356453,"title":"Bad Boys"}]}]';

				got = JSON.stringify(pairs);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var lists = [
						{
							"id": 5434364,
							"name": "New Releases"
						},
						{
							"id": 65456475,
							name: "Thrillers"
						}
					],
					videos = [
						{
							"listId": 5434364,
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"listId": 5434364,
							"id": 675465,
							"title": "Fracture"
						},
						{
							"listId": 65456475,
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"listId": 65456475,
							"id": 654356453,
							"title": "Bad Boys"
						}
					];

				return lists.map(function(list) {
					return {
						name: list.name,
						videos:
							videos.
								filter(function(video) {
									return video.listId === list.id;
								}).
								map(function(video) {
									return {id: video.id, title: video.title};
								})
					};
				});
			}
        </pre>
		<p class="post">Looks like you figured out that you can use map and filter to <i>join</i> two different arrays by a
			key. Now let's try a more complex example...</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 26: Converting from Arrays to <i>Deeper</i> Trees</h4>

		<p>Let's try creating a deeper tree structure. This time we have 4 separate arrays each containing lists, videos,
			boxarts, and bookmarks respectively. Each object has a parent id, indicating its parent. We want to build an
			array of list objects, each with a name and a videos array. The videos array will contain the video's id, title,
			bookmark time, and smallest boxart url. In other words we want to build the following structure:</p>
        <pre>
			[
				{
					"name": "New Releases",
					"videos": [
						{
							"id": 65432445,
							"title": "The Chamber",
							"time": 32432,
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg"
						},
						{
							"id": 675465,
							"title": "Fracture",
							"time": 3534543,
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture120.jpg"
						}
					]
				},
				{
					"name": "Thrillers",
					"videos": [
						{
							"id": 70111470,
							"title": "Die Hard",
							"time": 645243,
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard150.jpg"
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"time": 984934,
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg"
						}
					]
				}
			]
        </pre>

		<p><b>Note: please make sure when creating objects (both lists and videos) that you add properties in the same order
			as above. This doesn't impact the correctness of your code, but the verifier expects properties to be created in
			this order.</b></p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var lists = [
						{
							"id": 5434364,
							"name": "New Releases"
						},
						{
							"id": 65456475,
							name: "Thrillers"
						}
					],
					videos = [
						{
							"listId": 5434364,
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"listId": 5434364,
							"id": 675465,
							"title": "Fracture"
						},
						{
							"listId": 65456475,
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"listId": 65456475,
							"id": 654356453,
							"title": "Bad Boys"
						}
					],
					boxarts = [
						{ videoId: 65432445, width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
						{ videoId: 65432445, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" },
						{ videoId: 675465, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ videoId: 675465, width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
						{ videoId: 675465, width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ videoId: 70111470, width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
						{ videoId: 70111470, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" },
						{ videoId: 654356453, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
						{ videoId: 654356453, width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }
					],
					bookmarks = [
						{ videoId: 65432445, time: 32432 },
						{ videoId: 675465, time: 3534543 },
						{ videoId: 70111470, time: 645243 },
						{ videoId: 654356453, time: 984934 }
					];

				return lists. // complete this expression

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output">
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					pairs = fun(),
					got,
					expected = '[{"name":"New Releases","videos":[{"id":65432445,"title":"The Chamber","time":32432,"boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg"},{"id":675465,"title":"Fracture","time":3534543,"boxart":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg"}]},{"name":"Thrillers","videos":[{"id":70111470,"title":"Die Hard","time":645243,"boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg"},{"id":654356453,"title":"Bad Boys","time":984934,"boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg"}]}]';

				got = JSON.stringify(pairs);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
        <pre class="answer">
			function() {
				var lists = [
						{
							"id": 5434364,
							"name": "New Releases"
						},
						{
							"id": 65456475,
							name: "Thrillers"
						}
					],
					videos = [
						{
							"listId": 5434364,
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"listId": 5434364,
							"id": 675465,
							"title": "Fracture"
						},
						{
							"listId": 65456475,
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"listId": 65456475,
							"id": 654356453,
							"title": "Bad Boys"
						}
					],
					boxarts = [
						{ videoId: 65432445, width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
						{ videoId: 65432445, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" },
						{ videoId: 675465, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ videoId: 675465, width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
						{ videoId: 675465, width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ videoId: 70111470, width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
						{ videoId: 70111470, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" },
						{ videoId: 654356453, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
						{ videoId: 654356453, width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }
					],
					bookmarks = [
						{ videoId: 65432445, time: 32432 },
						{ videoId: 675465, time: 3534543 },
						{ videoId: 70111470, time: 645243 },
						{ videoId: 654356453, time: 984934 }
					];

				return lists.map(function(list) {
					return {
						name: list.name,
						videos:
							videos.
								filter(function(video) {
									return video.listId === list.id;
								}).
								concatMap(function(video) {
									return Array.zip(
										bookmarks.filter(function(bookmark) {
											return bookmark.videoId === video.id;
										}),
										boxarts.filter(function(boxart) {
											return boxart.videoId === video.id;
										}).
										reduce(function(acc,curr) {
											return acc.width * acc.height < curr.width * curr.height ? acc : curr;
										}),
										function(bookmark, boxart) {
											return { id: video.id, title: video.title, time: bookmark.time, boxart: boxart.url };
										});
							})
					};
				});

			}
        </pre>
		<p class="post">Wow! That's a large query, but the code is still small relative to the amount of work it's doing. If
			we rewrote this query with a series of loops our code would be much less self-describing. Loops don't give the
			reader any information about the kind of operation being performed. Every time you see a loop, you need to
			carefully read through the code to find out what's being done. Is it a projection? A filter? A reduction? Why
			use loops for querying data when we've demonstrated that the 5 functions can be used to create virtually any
			output we want?</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 27: Stock Ticker</h4>

		<p>Let's try an easier question. Let's say we have a collection of all of the prices for NASDAQ stocks over time.
			Every time the price of a stock changes on the NASDAQ ticker an entry is added to this collection. Let's say
			that ten days ago you bought shares in Microsoft, and now you want to print all of the MSFT share prices since
			then. Filter the collection for MSFT trades starting from ten days ago and print each price record (including
			the time stamp) using the print() function. <b>Note: this is not a trick question. It's as easy as it seems.</b>
		</p>
		<pre>
			// The pricesNASDAQ collection looks something like this...
			var pricesNASDAQ = [
				// ... from the NASDAQ's opening day
				{name: "ANGI", price: 31.22, timeStamp: new Date(2011,11,15) },
				{name: "MSFT", price: 32.32, timeStamp: new Date(2011,11,15) },
				{name: "GOOG", price: 150.43, timeStamp: new Date(2011,11,15)},
				{name: "ANGI", price: 28.44, timeStamp: new Date(2011,11,16)},
				{name: "GOOG", price: 199.33, timeStamp: new Date(2011,11,16)},
				// ...and up to the present.
			];
		</pre>
		<textarea class="code" rows="60" cols="80">
			function(pricesNASDAQ, printRecord) {
				var microsoftPrices,
					now = new Date(),
					tenDaysAgo = new Date( now.getFullYear(), now.getMonth(), now.getDate() - 10);

				// use filter() to filter the trades for MSFT prices recorded any time after 10 days ago
				microsoftPrices =
					pricesNASDAQ.
						filter(function(priceRecord) {	 // finish this expression

				// Print the trades to the output console
				microsoftPrices.
					forEach(function(priceRecord) {
						printRecord(priceRecord);
					});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<p>Console</p>

		<div class="output" style="height:200px;overflow:scroll">
		</div>
        <pre class="verifier">
			// Combine videos and bookmarks
			function(str, lesson) {
				preVerifierHook();
				var output = $(".output", lesson)[0],
					fun = eval("(" + str + ")"),
					stockSymbols = ["MSFT", "GOOG","NFLX","OSTK"],
					input = [{name: "MSFT", price: 32.32, timeStamp: new Date() }, {name: "GOOG", price: 150.43, timeStamp: new Date(2011,11,15)}],
					expected = [input[0]],
					items = [],
					counter = 0;
					confirmPrint = function(item) {
						items.push(item);
					},
					print = function(item) {
						output.innerHTML += "MSFT " + item.price + " at " + item.timeStamp.toString() + "<" + "br" + ">";
						output.scrollTop = output.scrollHeight;
						counter++;
						if (counter % 100 === 0) {
							output.innerHTML = "";
						}
					},
					stocks =
						Rx.Observable.
							interval(250).
							map(function() {
								var symbol = stockSymbols[Math.floor(Math.random() * stockSymbols.length)];
								return {name: symbol, price: 30 + ((Math.floor(Math.random() * 100))/200), timeStamp: new Date()};
							});

				fun(input, confirmPrint);

				if (JSON.stringify(items) !== JSON.stringify(expected)) {
					throw "Got " + JSON.stringify(items, null, 4) + ", expected " + JSON.stringify(expected, null, 4);
				}

				fun(stocks, print);
			}
		</pre>
        <pre class="answer">
			function(pricesNASDAQ, printRecord) {
				var microsoftPrices,
					now = new Date(),
					tenDaysAgo = new Date( now.getFullYear(), now.getMonth(), now.getDate() - 10);

				// use filter() to filter the trades for MSFT prices recorded any time after 10 days ago
				microsoftPrices =
					pricesNASDAQ.
						filter(function(priceRecord) {
						  return priceRecord.name === 'MSFT' && priceRecord.timeStamp > tenDaysAgo;
						});

				// Print the trades to the output console
				microsoftPrices.
					forEach(function(priceRecord) {
						printRecord(priceRecord);
					});
			}
        </pre>
		<div class="post">
			<p><b>Notice that the console is changing over time.</b> Now look at the time stamps on the stock prices. We're
				displaying stock prices sampled <i>after</i> we ran our program! How could our array have contained stock
				price records from the future? Did we accidentally rip a hole in the space-time continuum?</p>

			<p>The solution to the riddle is that <b>pricesNASDAQ is <u>not</u> an array</b>. Unlike an array, which can
				only store a snapshot of stock prices, this new type can react to changes and update over time.</p>

			<p>In the next section I'll reveal the inner workings of this magical type. You'll learn how you can use it to
				model everything from mouse events to asynchronous JSON requests. Finally I'll show you how <b>you can query
					this type using the 5 query functions you already know.</b> It's about time we gave this magical type a
				name...</p>
			<h2>Working with Observables</h2>

			<p>Microsoft's open-source <a href="http://msdn.microsoft.com/en-us/data/gg577609.aspx">Reactive Extensions</a> library
				introduces a new collection type to Javascript: <b>Observable.</b> An Observable is a lot like an Event. Like an
				Event, <b>an Observable is a sequence of values that a data producer <i>pushes</i> to the consumer.</b> However
				unlike an Event, <b>an Observable can signal to a listener that it has completed,</b> and will send no more data.
			</p>

			<p>Observables can send data to consumers asynchronously. Unlike Array, there's no Javascript literal syntax for
				creating Observable sequences. However we can build a helper method that visually describes the contents of
				sequences as well as the times between each item's arrival. The <b>seq</b> function creates an Observable from an
				array of items, and adds a delay for every empty item encountered. Every ,,, adds up to a second.</p>
			<pre>
				// An array of numbers 1,2,3
				var numbers123Array =      [1,2,3];

				// A sequence that returns 1, and then after 4 seconds returns 2,
				// and then after another second returns 3, and then completes.
				var numbers123Observable = seq([1,,,,,,,,,,,,2,,,3]);

				// Like Arrays, Observables can contain any object - even Arrays.
				var observableOfArrays = seq([ [1,2,3],,,,,,[4,5,6],,,,,,,,,,,[1,2] ]);
			</pre>
			<p>Observables are a sequence of values, delivered one after the other. Therefore it's possible that an Observable can
				go on sending data to a listener forever just like a mouse move event. To create a sequence that doesn't complete,
				you can add a trailing ,,, to the end of the items passed to seq().</p>
			<pre>
				// The trailing ,,, ensures that the sequence will <u>not</u> complete.
				var mouseMovesObservable =
					seq([ {x: 23, y: 55},,,,,,,{x: 44, y: 99},,,{x:55,y:99},,,{x: 54, y:543},,, ]);

				// No trailing ,,, indicates that sequence <u>will</u> complete.
				var numbers123Observable = seq([1,,,2,,,3]);
			</pre>
			<p>Querying Arrays only gives us a snapshot. By contrast, querying Observables allows us to create data sets that react
				and update as the system changes over time. This enables a very powerful type of programming known as <i>reactive
					programming</i>.</p>

			<p>Let's start off by contrasting Observable with Events...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 28: Subscribing to an event</h4>

		<p>You're probably used to thinking about events as a list of handlers stored in an object. In this example, we
			subscribe to a button click event and then unsubscribe the first time the button is clicked.</p>
		<textarea class="code" rows="60" cols="80">
			function(button) {
				// the button click handler
				var handler = function(ev) {
					// Unsubscribe from the button event.
					button.removeEventListener("click", handler);

					alert("Button was clicked. Unsubscribing from event.");
				};

				// add the button click handler
				button.addEventListener("click", handler);
			}
		</textarea>
		<button class="go">运行</button>
		<div class="output" style="text-align:center">
			<button class="button" id="thisfirstbutton">Click this button after running the program</button>
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					button = $('.button', lesson)[0];

				fun(button);
			}
		</pre>
		<p class="post">Ask yourself this question: <b>How is subscribing to an event different than traversing an
			array?</b> Both operations involve sending a listener a sequence of items by repeatedly invoking a function. So
			why can't we traverse Arrays and Events the same way?</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 29: Traversing an Event</h4>

		<p>Subscribing to an Event and traversing an Array are fundamentally the same operation. The only difference is that
			<b>Array traversal is synchronous and completes, and Event traversal is asynchronous and <u>never completes</u>.</b>
			If we convert a button click Event to an Observable object, we can use forEach() to traverse the Event.</p>
		<textarea class="code" rows="60" cols="80">
			function(button) {
				var buttonClicks = Observable.fromEvent(button, "click");

				// In the case of an Observable, forEach returns a subscription object.
				var subscription =
					buttonClicks.
						forEach(function(clickEvent) {
							alert("Button was clicked. Stopping Traversal.");

							// Stop traversing the button clicks
							subscription.dispose();
						});
			}
		</textarea>
		<button class="go">运行</button>
		<div class="output" style="text-align:center">
			<button class="button">Click this button after running the program</button>
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					button = $('.button', lesson)[0];

				fun(button);
			}
		</pre>
		<div class="post">
			<p>Notice that <b>Observable's forEach() function returns a Subscription object.</b> Disposing of a Subscription
				object unsubscribes from the event and prevents memory leaks. Disposing of a subscription is the
				asynchronous equivalent of stopping half-way through a counting for loop.</p>

			<p>Disposing of a Subscription object is basically the same as calling removeEventListener(). On the surface,
				these two approaches to Event handling don't seem to be very different. Under the circumstances, why should
				we bother converting Events to Observables? The reason is that <b>if we convert Events to Observable
					Objects, we can use powerful functions to transform them.</b> In the next exercise we'll learn how we
				can use one such function to avoid dealing with Subscriptions in many cases...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 30: Completing Sequences with take()</h4>

		<p><b>Have you ever wished that you could listen for the next occurrence of an event and then immediately
			unsubscribe?</b> For example, developers will often attach an event handler to window.onload, expecting that
			their event handler will only be called once.</p>
		<pre>
			window.addEventListener(
				"load",
				function()
					// do some work here, but expect this function will only be called once.
				})
		</pre>
		<p>In instances such as this, it's good practice to unsubscribe from the event after it's fired. Failing to
			unsubscribe is a <b>memory leak</b>. Depending on the circumstances, memory leaks can seriously destablize your
			application and can be very difficult to track down. Unfortunately unsubscribing from an event after one
			occurrence can be cumbersome:
		</p>
		<pre>
			var handler = function() {
				// do some work here, then unsubscribe from the event
				window.removeEventListener("load", handler)
			};
			window.addEventListener("load", handler);
		</pre>
		<p>Wouldn't it be nice if there was an easier way to code this? That's why Observable has a take() function. The
			take() function works like this...
		</p>
		<pre>
			seq([1,,,2,,,3,,,4,,,5,,,6,,,]).take(3) === seq([1,,,2,,,3]);
		</pre>
		<p>An Observable based on an Event will <u>never</u> complete on its own. The take() function creates a new sequence
			that completes after a discrete number of items arrive. This is important, because unlike an Event, <i>when an
				Observable sequence completes it unsubscribes all of its listeners.</i> That means that <b>if we use take()
				to complete our Event sequence, we don't need to unsubscribe!</b>
		</p>

		<p>Let's repeat the previous exercise, in which we listened for a single button click and then unsubscribed. This
			time let's use the take() function to complete the sequence after the button is clicked.</p>
		<textarea class="code" rows="60" cols="80">
			function(button) {
				var buttonClicks = Observable.fromEvent(button, "click");

				// Use take() to listen for only one button click
				// and unsubscribe.
				buttonClicks.
					// Insert take() call here
					forEach(function(clickEvent) {
						alert("Button was clicked once. Stopping Traversal.");
					});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output" style="text-align:center">
			<button class="button">Click this button after pressing the run button</button>
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					button = $('.button', lesson)[0];

				fun(button);
			}
		</pre>
		<pre class="answer">
			function(button) {
				var buttonClicks = Observable.fromEvent(button, "click");

				// Use take() to listen for only one button click
				// and unsubscribe.
				buttonClicks.
					take(1).
					forEach(function(priceRecord) {
						alert("Button was clicked once. Stopping Traversal.");
					});
			}
		</pre>
		<div class="post">
			<p>The take() function is great way of listening for a discrete number of events and then unsubscribing, but
				Observable has an even <i>more</i> flexible function that we can use to complete sequences...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 31: Completing sequences with takeUntil()</h4>

		<p><b>Have you ever wanted to unsubscribe from one Event when another Event fires?</b> Observable's takeUntil() function
		is a convenient way of completing a sequence when another Event occurs.</b> Here's how takeUntil() works:
		</p>
		<pre>
			var numbersUntilStopButtonPressed =
				seq(              [ 1,,,2,,,3,,,4,,,5,,,6,,,7,,,8,,,9,,, ]).
					takeUntil(seq([  ,,, {eventType: "click"},,, ]) )                    === seq([ 1,,,2 ])
		</pre>
		<p>Earlier we (unknowningly) built a dynamic Microsoft price stock ticker using Observable. The problem with that stock
			ticker was that <i>it kept going on forever</i>. If left unchecked, all the entries in the log could use up all of
			the memory on the page. In the exercise below, filter the Observable sequence of NASDAQ prices for MSFT stock
			prices, use the fromEvent() function to create an Observable .
		</p>
		<textarea class="code" rows="60" cols="80">
			function(pricesNASDAQ, printRecord, stopButton) {
				var stopButtonClicks = // ----- To finish this expression, use Observable.fromEvent to convert the "click" event on the stop button to an Observable
					microsoftPrices =
						pricesNASDAQ.
							filter(function(priceRecord) {
								return priceRecord.name === "MSFT";
							}).
							// ----- To finish this expression, use takeUntil to complete the sequence when stopButtonClicks fires.

				microsoftPrices.
					forEach(function(priceRecord) {
						printRecord(priceRecord);
					});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<button class="stop">Stop</button>
		&lt;-Press this button to complete the sequence of microsoft stock prices.
		<p>Console</p>

		<div class="output" style="height:200px;overflow:scroll">
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					output = $(".output", lesson)[0],
					stopButton = $('.stop', lesson)[0],
					stockSymbols = ["MSFT", "GOOG","NFLX","OSTK"],
					input = [{name: "MSFT", price: 32.32, timeStamp: new Date() }, {name: "GOOG", price: 150.43, timeStamp: new Date(2011,11,15)}],
					expected = [input[0]],
					items = [],
					counter = 0,
					print = function(item) {
						output.innerHTML += "MSFT " + item.price + " at " + item.timeStamp.toString() + "<" + "br" + ">";
						output.scrollTop = output.scrollHeight;
						counter++;
						if (counter % 100 === 0) {
							output.innerHTML = "";
						}
					},
					stocks =
						Rx.Observable.
							interval(250).
							map(function() {
								var symbol = stockSymbols[Math.floor(Math.random() * stockSymbols.length)];
								return {name: symbol, price: 30 + ((Math.floor(Math.random() * 100))/200), timeStamp: new Date()};
							});

				fun(stocks, print, stopButton);
			}
		</pre>
		<pre class="answer">
			function(pricesNASDAQ, printRecord, stopButton) {
				var stopButtonClicks = Observable.fromEvent(stopButton,"click"),
					microsoftPrices =
						pricesNASDAQ.
							filter(function(priceRecord) {
								return priceRecord.name === "MSFT";
							}).
							takeUntil(stopButtonClicks);

				microsoftPrices.
					forEach(function(priceRecord) {
						printRecord(priceRecord);
					});
			}
		</pre>
		<div class="post">
			<p>We've learned that Observable sequences are much more powerful than raw events, because they can complete. <b>The
				take() and takeUntil() functions are powerful enough to ensure that we never have to unsubscribe from another event
				again!</b> This reduces the risk of memory leaks and makes our code more readable.
			</p>

			<p>Here's what we learned in this section:</p>
			<ul>
				<li>We can traverse Observables using forEach().</li>
				<li>We can use fromEvent() to convert Events into Observables that never complete.</li>
				<li>We can apply take() and takeUntil() to an Observable to create a new sequence which <i>does</i> complete.</li>
			</ul>
			<p>In the next section we'll learn how to combine events to create more complex events. You'll be suprised how easily
				you can solve complex, asynchronous problems!
			</p>

			<h3>Querying Observables</h3>

			<p>What's the difference between these two tasks?</p>
			<ul>
				<li>Creating a flat list of movies with a rating of 5.0 from a bunch of movie lists.</li>
				<li>Creating a sequence of all the mouse drag events from the mouseDown, mouseMove, and mouseUp events.</li>
			</ul>
			<p>You might think of them as different, and might code them very differently, but <b>these tasks are fundamentally the
				same.</b> Both of these tasks are <i>queries</i>, and can be solved using the functions you've learned in these
				exercises.
			</p>

			<p><b>The difference between traversing an Array and traversing an Observable is <i>the direction in which the data
				moves.</i></b> When traversing an Array, the client <i>pulls</i> data from the data source, blocking until it gets a
				result. When traversing Observables, the data source <i>pushes</i> data at the client whenever it arrives.
			</p>

			<p>It turns out that the direction in which data moves is <i>orthogonal</i> to querying that data. In other words, <b>when
				we're querying data it doesn't matter whether we pull data, or data is pushed at us.</b> In either case the query
				methods make the same transformations. The only thing that changes is the input and output type respectively. If we
				filter an Array, we get a new Array. If we filter an Observable, we get a new Observable, and so on.
			</p>

			<p>Take a look at how the query methods transform Observables and Arrays:</p>
			<pre>
				// <b>map()</b>

				[1,2,3].map(function(x) { return x + 1 })                       === [2,3,4]
				seq([1,,,2,,,3]).map(function(x) { return x + 1})               === seq([2,,,3,,,4])
				seq([1,,,2,,,3,,,]).map(function(x) { return x + 1 })           === seq([2,,,3,,,4,,,])

				// <b>filter()</b>

				[1,2,3].filter(function(x) { return x > 1; })                   === [2,3]
				seq([1,,,2,,,3]).filter(function(x) { return x > 1; })          === seq([2,,,3])
				seq([1,,,2,,,3,,,]).filter(function(x) { return x > 1; })       === seq([2,,,3,,,])

				// <b>concatAll()</b>

				[ [1, 2, 3], [4, 5, 6] ].concatAll()                             === [1,2,3,4,5,6]
				seq([ seq([1,,,2,,,3]),,,seq([4,,,5,,,6]) ]).concatAll()         === seq([1,,,2,,,3,,,4,,,5,,,6])

				// If a new sequence arrives before all the items
				// from the previous sequence have arrived, no attempt
				// to retrieve the new sequence's elements is made until
				// the previous sequence has completed. As a result the
				// order of elements in the sequence is preserved.
				seq([
					seq([1,,,, ,2, ,3])
					,,,seq([,,4, ,5, ,,6]) ]).
					concatAll()                                                  === seq([1,,,,,2,,3,,4,,5,,,6])

				// Notice that as long as at least one sequence being
				// concatenated is incomplete, the concatenated sequence is also
				// incomplete.
				seq([
					seq([1,, ,,, ,,,2,,,3])
					,,,seq([4,,,5,,, ,,, ,,6,,,]) ]).
					concatAll()                                                  === seq([1,,,4,,,5,,,2,,,3,,,6,,,])

				// <b>reduce()</b>

				[ 1, 2, 3 ].reduce(sumFunction)                                 === [ 6 ]
				seq([ 1,,,2,,,3 ]).reduce(sumFunction)                          === seq([,,,,,,6])

				// Reduced sequences do <u>not</u> complete until the
				// sequence does.
				seq([ 1,,,2,,,3,,, ]).reduce(sumFunction)                       === seq([ ,,,,,,,,,])

				// <b>zip()</b>

				// In both Arrays and Observables, the zipped sequence
				// completes as soon as either the left or right-hand
				// side sequence completes.
				Array.zip([1,2],[3,4,5], sumFunction)                           === [4,6]
				Observable.zip(seq([1,,,2]),seq([3,,,4,,,5]), sumFunction)      === seq([4,,,6])

				// <b>take()</b>
				[1,2,3].take(2)                                                 === [1, 2]
				seq([ 1,,,2,,,3 ]).take(2)                                      === seq([ 1,,,2 ])
				seq([ 1,,,2,,,3,,, ]).take(2)                                   === seq([ 1,,,2 ])

				// <b>takeUntil()</b>

				// takeUntil works for Arrays, but it's not very useful
				// because the result will always be an empty array.
				[1,2,3].takeUntil([1])                                          === []

				seq([1,,,2,,,3,,, ]).takeUntil(
				seq([ ,,, ,,4 , }))                                             === seq([ 1,,,2 ])

			</pre>
			<p>Remember when I <a href="#indexers">prohibited the use of array indexers?</a> The reason for that restriction should
				now become clearer to you. Whereas the 5 functions can be used on <i>any</i> collection, indexers can only be used
				on collections that support random-access (like Array). If you avoid indexers and stick to the functions you've
				learned in this tutorial, you'll have a unified programming model for transforming <i>any</i> collection. Having a
				unified programming model makes it trivial to convert synchronous code to asynchronous code, a process which would
				otherwise be very difficult. As we've demonstrated, you don't need indexers to perform complex collection
				transformations.</p>

			<p>Now that we've seen that we can query asychronous and synchronous data sources using the same programming model,
				let's use Observable and our query functions to create complex new events.</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 32: Creating a mouse drag event</h4>

		<p>Remember the exercise we solved earlier? The one in which we retrieved all the movies with a rating of 5.0 from
			an array of movie lists? If we were to describe the solution in pseudocode it might read something like
			this...
		</p>

		<p><b>"For every movie list, retrieve only those videos with a rating of 5.0"</b></p>
		<pre>
			var moviesWithHighRatings =
				movieLists.
					concatMap(function(movieList) {
						return movieList.videos.
							filter(function(video) {
								return video.rating === 5.0;
							});
					});
		</pre>
		<p>Now we're going to create a mouseDrag event for a DOM object. If we were to describe <i>this</i> problem as
			pseudocode it might read something like this...
		</p>

		<p><b>"For every
			<del>movie list</del>
			mouse down event on the sprite, retrieve only those
			<del>videos with a rating of 5.0</del>
			mouse move events that occur before the next mouse up event."</b>
		</p>
		</p>
		<textarea class="code" rows="60" cols="80">
			function(sprite, spriteContainer) {
				var spriteMouseDowns = Observable.fromEvent(sprite, "mousedown"),
					spriteContainerMouseMoves = Observable.fromEvent(spriteContainer, "mousemove"),
					spriteContainerMouseUps = Observable.fromEvent(spriteContainer, "mouseup"),
					spriteMouseDrags =
						// For every mouse down event on the sprite...
						spriteMouseDowns.
							// --------------------------------------------------------
							//					  INSERT CODE HERE
							// --------------------------------------------------------
							// Complete this expression...
							// For every mouse down event, return the mouse move event
							// sequence until a mouse up event occurs.

				// For each mouse drag event, move the sprite to the absolute page position.
				spriteMouseDrags.forEach(function(dragPoint) {
					sprite.style.left = dragPoint.pageX + "px";
					sprite.style.top = dragPoint.pageY + "px";
				});
			}
		</textarea>
		<button class="go">运行</button>
		<!-- <button class="showAnswer">显示答案</button> -->
		<button class="resetSprite">Reset Sprite</button>
		<div class="control output container" style="height:200px;text-align:center">
            <span class="control sprite" style="position:absolute; border: solid 1px black; background-color: white;z-index:23">
                Sprite
            </span>
			<span style="position:relative; top: 100px;">Sprite Container</span>
		</div>

		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					output = $(".output", lesson)[0],
					container = $(".container", lesson)[0],
					sprite = $(".sprite",lesson)[0],
					moveSprite = function(point) {
						sprite.style.left = point.pageX + "px";
						sprite.style.top = point.pageY + "px";
					}

				fun(sprite, container, moveSprite);
			}
		</pre>
		<pre class="answer">
			function(sprite, spriteContainer) {
				var spriteMouseDowns = Observable.fromEvent(sprite, "mousedown"),
					spriteContainerMouseMoves = Observable.fromEvent(spriteContainer, "mousemove"),
					spriteContainerMouseUps = Observable.fromEvent(spriteContainer, "mouseup"),
					spriteMouseDrags =
						// For every mouse down event on the sprite...
						spriteMouseDowns.
							concatMap(function(contactPoint) {
								// ...retrieve all the mouse move events on the sprite container...
								return spriteContainerMouseMoves.
									// ...until a mouse up event occurs.
									takeUntil(spriteContainerMouseUps);
							});

				// For each mouse drag event, move the sprite to the absolute page position.
				spriteMouseDrags.forEach(function(dragPoint) {
					sprite.style.left = dragPoint.pageX + "px";
					sprite.style.top = dragPoint.pageY + "px";
				});
			}
        </pre>
		<p class="post">Now we're really cooking. We just created a complex event with a few lines of code. We didn't have to
			deal with any subscriptions objects, or write any stateful code whatsoever. Let's try something a little
			harder.</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 33: Improving our mouse drag event</h4>

		<p>Our mouse drag event is a little <i>too</i> simple. Notice that when we drag around the sprite, it always
			positions itself at the top-left corner of the mouse. Ideally we'd like our drag event to offset its
			coordinates, based on where the mouse was when the mouse down event occurred. This will make our mouse drag more
			closely resemble moving a real object with our finger.
		</p>

		<p>Let's see if you can adjust the coordinates in the mouse drag event, based on the mousedown location on the
			sprite. The mouse events are sequences, and they look something like this:
		</p>

		<pre>
			spriteContainerMouseMoves =
				seq([ {x: 200, y: 400, offsetX: 10, offsetY: 15},,,{x: 210, y: 410, offsetX: 20, offsetY: 26},,, ])
		</pre>
		<p>
			Each item in the mouse event sequences contains an x, y value that represents that absolute location of the
			mouse event on the page. The moveSprite() function uses these coordinates to position the sprite. Each item in
			the sequence <i>also</i> contains a pair of offsetX and offsetY properties that indicate the position of the
			mouse event relative to the event target.
		</p>

		<textarea class="code" rows="60" cols="80">
			function(sprite, spriteContainer) {
				// All of the mouse event sequences look like this:
				// seq([ {pageX: 22, pageY: 3423, offsetX: 14, offsetY: 22} ,,, ])
				var spriteMouseDowns = Observable.fromEvent(sprite, "mousedown"),
					spriteContainerMouseMoves = Observable.fromEvent(spriteContainer, "mousemove"),
					spriteContainerMouseUps = Observable.fromEvent(spriteContainer, "mouseup"),
					// Create a sequence that looks like this:
					// seq([ {pageX: 22, pageY:4080 },,,{pageX: 24, pageY: 4082},,, ])
					spriteMouseDrags =
						// For every mouse down event on the sprite...
						spriteMouseDowns.
							concatMap(function(contactPoint) {
								// ...retrieve all the mouse move events on the sprite container...
								return spriteContainerMouseMoves.
									// ...until a mouse up event occurs.
									takeUntil(spriteContainerMouseUps).
									// ------------   INSERT CODE HERE  -----------------
									// Project each mouse move object into a new object
									// with adjusted pageX and pageY properties.
									// Translate each page coordinate based on the value
									// of the offsetX and offsetY properties in the
									// contactPoint.
									// -------------------------------------------------
									// Complete expression...
							});

				// For each mouse drag event, move the sprite to the absolute page position.
				spriteMouseDrags.forEach(function(dragPoint) {
					sprite.style.left = dragPoint.pageX + "px";
					sprite.style.top = dragPoint.pageY + "px";
				});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<button class="resetSprite">Reset Sprite</button>
		<div class="control output container" style="height:200px;text-align:center">
            <span class="control sprite" style="position:absolute; border: solid 1px black; background-color: white;z-index:23">
                Sprite
            </span>
			<span style="position:relative; top: 100px;">Sprite Container</span>
		</div>

		<pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					output = $(".output", lesson)[0],
					container = $(".container", lesson)[0],
					sprite = $(".sprite",lesson)[0],
					moveSprite = function(point) {
						sprite.style.left = point.pageX + "px";
						sprite.style.top = point.pageY + "px";
					}

				fun(sprite, container, moveSprite);
			}
		</pre>
		<pre class="answer">
			function(sprite, spriteContainer) {
				// All of the mouse event sequences look like this:
				// seq([ {pageX: 22, pageY: 3423, offsetX: 14, offsetY: 22} ,,, ])
				var spriteMouseDowns = Observable.fromEvent(sprite, "mousedown"),
					spriteContainerMouseMoves = Observable.fromEvent(spriteContainer, "mousemove"),
					spriteContainerMouseUps = Observable.fromEvent(spriteContainer, "mouseup"),
					// Create a sequence that looks like this:
					// seq([ {pageX: 22, pageY:4080 },,,{pageX: 24, pageY: 4082},,, ])
					spriteMouseDrags =
						// For every mouse down event on the sprite...
						spriteMouseDowns.
							concatMap(function(contactPoint) {
								// ...retrieve all the mouse move events on the sprite container...
								return spriteContainerMouseMoves.
									// ...until a mouse up event occurs.
									takeUntil(spriteContainerMouseUps).
									map(function(movePoint) {
										return {
											pageX: movePoint.pageX - contactPoint.offsetX,
											pageY: movePoint.pageY - contactPoint.offsetY
										};
									});
							});

				// For each mouse drag event, move the sprite to the absolute page position.
				spriteMouseDrags.forEach(function(dragPoint) {
					sprite.style.left = dragPoint.pageX + "px";
					sprite.style.top = dragPoint.pageY + "px";
				});
			}
        </pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 34: HTTP requests</h4>

		<p>Events aren't the only source of asynchronous data in an application. There's also HTTP requests. Most of the
			time HTTP requests are exposed via a <b>callback-based API</b>. To receive data asynchronously from a
			callback-based API, the client typically passes a success and error handler to the function. When the
			asynchronous operation completes, the appropriate handler is called with the data. In this exercise we'll use
			jQuery's getJSON api to asynchronously retrieve data.
		</p>
		<textarea class="code" rows="60" cols="80">
			function($) {
				$.getJSON(
					"http://api-global.netflix.com/queue",
					{
						success: function(json) {
							alert("Data has arrived.");
						},
						error: function(ex) {
							alert("There was an error.")
						}
					});
			}
		</textarea>
		<button class="go">运行</button>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")");
				fun(jQueryMock);
			}
		</pre>
		<div class="post">
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 35: Sequencing HTTP requests with callbacks</h4>

		<p>Let's say that we're writing the startup flow for a web application. On startup, the application must perform the
			following operations:</p>
		<ol>
			<li>Download the URL prefix to use for all subsequent AJAX calls. This URL prefix will vary based on what AB
				test the user is enrolled in.
			</li>
			<li>Use the url prefix to do the following actions in parallel:
				<ul>
					<li>Retrieve a movie list array</li>
					<li>Retrieve configuration information and...
						<ul>
							<li>make a follow up call for an instant queue list if the config property "showInstantQueue" is
								truthy
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>If an instant queue list was retrieved, append it to the end of movie list.</li>
			<li>If all operations were successful then display the movie lists <i>after</i> the window loads. Otherwise
				inform the user that there was a connectivity error.
			</li>
		</ol>
		<textarea class="code" rows="60" cols="80">
			function(window, $, showMovieLists, showError) {
				var error,
					configDone,
					movieLists,
					queueList,
					windowLoaded,
					outputDisplayed,
					errorHandler = function() {
						// Otherwise show the error.
						error = "There was a connectivity error";

						// We may be ready to display out
						tryToDisplayOutput();
					},
					tryToDisplayOutput = function() {
						if (outputDisplayed) {
							return;
						}
						if (windowLoaded) {
							if (configDone && movieLists !== undefined) {
								if (queueList !== undefined) {
									movieLists.push(queueList);
								}
								outputDisplayed = true;
								showMovieLists(JSON.stringify(movieLists));
							}
							else if (error) {
								outputDisplayed = true;
								showError(error);
							}
						}
					},
					windowLoadHandler = function() {
						windowLoaded = true;

						// Remember to unsubscribe from events
						window.removeEventListener("load", windowLoadHandler);

						// This may be the last task we're waiting on, so try and display output.
						tryToDisplayOutput();
					};

				// Register for the load event
				window.addEventListener("load", windowLoadHandler);

				// Request the service url prefix for the users AB test
				$.getJSON(
					"http://api-global.netflix.com/abTestInformation",
					{
						success: function(abTestInformation) {
							// Request the member's config information to determine whether their instant
							// queue should be displayed.
							$.getJSON(
								"http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/config",
								{
									success: function(config) {
										// Parallel retrieval of movie list could've failed,
										// in which case we don't want to issue this call.
										if (!error) {
											// If we're supposed to
											if (config.showInstantQueue) {
												$.getJSON(
													"http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/queue",
													{
														success: function(queueMessage) {
															queueList = queueMessage.list;

															configDone = true;
															tryToDisplayOutput();
														},
														error: errorHandler
													});
											}
											else {
												configDone = true;
												tryToDisplayOutput();
											}
										}
									},
									error: errorHandler
								});

							// Retrieve the movie list
							$.getJSON(
								"http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/movieLists",
								{
									success: function(movieListMessage) {
										movieLists = movieListMessage.list;
										tryToDisplayOutput();
									},
									error: errorHandler
								});
						},
						error: errorHandler
					});
			}
		</textarea>
		<button class="go">运行</button>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					NOOP = function() {};

				fun(
					{
						addEventListener: function(event, handler) {
							window.setTimeout(handler, 200)
						},
						removeEventListener: NOOP
					},
					jQueryMock,
					function(output) { alert(output) },
					function(output) { alert(output) });
			}
		</pre>
		<div class="post">
			<p>It's fair to say that <b>sequencing HTTP requests with callbacks is <i>very</i> hard.</b> In order to perform
				two tasks in parallel, we have to introduce a variable to track the status of each task. Every time one of
				the parallel tasks completes it must check whether its sibling task has also completed. If both have
				completed, only then can we move forward. In the example above, every time a task is finished the
				tryToDisplayOutput() function is called to check if the program was ready to display output. This function
				checks the status of all tasks and displays the output if possible.
			</p>

			<p>With a callback-based API, asynchronous error handling is also very complicated. In synchronous programs, a
				unit of work is cancelled when an exception is thrown. By contrast, in our program we had to explicitly
				track whether an error occurred in parallel to prevent an unnecessary call for the instant queue. Javascript
				provides us with special support for synchronous error handling with the keywords try/catch/throw.
				Unfortunately no such support is available for asynchronous programs.
			</p>

			<p>The Observable interface is a much more powerful way of working with asynchronous APIs than callbacks. We'll
				see that Observables can free us from having to track the status of tasks that are run in parallel, just
				Observables frees us from having to track Event Subscriptions. We'll also see that Observable gives us the
				same error propagation semantics in asynchronous programs that we expect in synchronous programs. Finally
				we'll learn that by converting callback-based APIs to Observables, we can query them along with Events to
				build much more expressive programs.
			</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 36: Traversing callback-based Asynchronous APIs</h4>

		<p><b>If a callback API were a sequence, what kind of sequence would it be?</b> We've seen that UI Event sequences
			can contain anywhere from 0 to infinite items, but will never complete on their own.
		</p>
		<pre>
			mouseMoves === seq([ {x: 23, y: 55},,,,,,,{x: 44, y: 99},,,{x:55,y:99},,,{x: 54, y:543},,, ]);
		</pre>
		<p>In contrast, if we were to convert output from the $.getJSON() function we've been using into a sequence it would
			always return a sequence that completes after sending a single item.
		</p>
		<pre>
			getJSONAsObservable("http://api-global.netflix.com/abTestInformation") ===
				seq([ { urlPrefix: "billboardTest" } ])
		</pre>
		<p>It might seem strange to create sequences that contain only one object. We <i>could</i> introduce an
			Observable-like type specifically for scalar values, but that would make callback-based APIs more difficult to
			query with Events. Thankfully, an Observable sequence is flexible enough to model both.
		</p>

		<p><b>So how do we convert a callback API into an Observable sequence?</b> Unfortunately, because callback-based
			APIs vary so much in their interfaces, we can't create a conversion function like we did with fromEvent().
			However there is a more flexible function we can use to build Observable sequences...
		</p>

		<p><b>Observable.create() is powerful enough to convert any asynchronous API into an Observable.</b>
			Observable.create() relies on the fact that all asynchronous APIs have the following semantics:
		</p>
		<ol>
			<li>The client needs to be able to receive data.</li>
			<li>The client needs to be able to receive error information.</li>
			<li>The client needs to be able to be alerted that the operation is complete.</li>
			<li>The client needs to be able to indicate that they're no longer interested in the result of the operation.</li>
		</ol>
		<p>In the following example, we'll use the Observable.create() function to create an Observable that issues a
			request to getJSON when it's traversed.
		</p>
		<textarea class="code" rows="60" cols="80">
			function(window, $) {
				var getJSON = function(url) {
					return Observable.create(function(observer) {
						var subscribed = true;

						$.getJSON(url,
							{
								success:
									function(data) {
										// If client is still interested in the results, send them.
										if (subscribed) {
											// Send data to the client
											observer.onNext(data);
											// Immediately complete the sequence
											observer.onCompleted();
										}
									},
								error: function(ex) {
									// If client is still interested in the results, send them.
									if (subscribed) {
										// Inform the client that an error occurred.
										observer.onError(ex);
									}
								}
							});

						// Definition of the Subscription objects dispose() method.
						return function() {
							subscribed = false;
						}
					});
				};

				var subscription =
					getJSON("http://api-global.netflix.com/abTestInformation").
						forEach(
							// observer.onNext()
							function(data) {
								alert(JSON.stringify(data));
							},
							// observer.onError()
							function(err) {
								alert(err)
							},
							// observer.onCompleted()
							function() {
								alert("The asynchronous operation has completed.")
							});
			}
		</textarea>
		<button class="go">运行</button>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					NOOP = function() {};

				fun(
					{
						addEventListener: function(event, handler) {
							window.setTimeout(handler, 200)
						},
						removeEventListener: NOOP
					},
					jQueryMock,
					function(output) { alert(output) },
					function(output) { alert(output) });
			}
		</pre>
		<div class="post">
			<p>Understand that <b>the function passed to Observable.create() is the definition of the forEach() function for
				<i>this</i> Observable.</b> In other words, all we have to do to define an Observable is to define its
				traversal function. Notice that although we pass three functions to the Observable's forEach() function, the
				function we pass to Observable.create() accepts only one value: an Observer. An Observer is just a triple
				containing three handlers:</p>
			<ul>
				<li>The onNext() handler used to send data to the client.</li>
				<li>The onError() handler used to send error information to the client.</li>
				<li>The onCompleted() handler used to inform the client that the sequence has completed.</li>
			</ul>
			<p>The three handlers we pass to forEach() are packaged together into a single Observer object for convenience.
				Finally Observable.create() returns a function that defines the dispose() method of the Subscription object
				during Traversal. Like the Observer, the Observable.create() function creates the Subscription object for us
				and uses our function as the dispose() definition.</p>

			<p>Now that we've built a version of the getJSON function that returns an Observable sequence, let's use it to
				improve our solution to the previous exercise...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 37: Sequencing HTTP requests with Observable</h4>

		<p>Let's use the getJSON function that returns Observables, and the Observable.fromEvent() to complete the exercise
			we completed earlier.</p>
		<textarea class="code" rows="60" cols="80">
			function(window, getJSON, showMovieLists, showError) {
				var movieListsSequence =
					Observable.zip(
						getJSON("http://api-global.netflix.com/abTestInformation").
							concatMap(function(abTestInformation) {
								return Observable.zip(
									getJSON("http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/config").
										concatMap(function(config) {
											if (config.showInstantQueue) {
												return getJSON("http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/queue").
													map(function(queueMessage) {
														return queueMessage.list;
													});
											}
											else {
												return Observable.returnValue(undefined);
											}
										}),
									getJSON("http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/movieLists"),
									function(queue, movieListsMessage) {
										var copyOfMovieLists = Object.create(movieListsMessage.list);
										if (queue !== undefined) {
											copyOfMovieLists.push(queue);
										}

										return copyOfMovieLists;
									});
							}),
						Observable.fromEvent(window, "load"),
						function(movieLists, loadEvent) {
							return movieLists;
						});

				movieListsSequence.
					forEach(
						function(movieLists) {
							showMovieLists(movieLists);
						},
						function(err) {
							showError(err);
						});
			}
		</textarea>
		<button class="go">运行</button>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					getJSON = function(url) {
						return Observable.create(function(observer) {
							var subscribed = true;

							jQueryMock.getJSON(url,
								{
									success:
										function(data) {
											// If client is still interested in the results, send them.
											if (subscribed) {
												// Send data to the client
												observer.onNext(data);
												// Immediately complete the sequence
												observer.onCompleted();
											}
										},
									error: function(ex) {
										// If client is still interested in the results, send them.
										if (subscribed) {
											// Inform the client that an error occurred.
											observer.onError(ex);
										}
									}
								});

							// Definition of the Subscription objects dispose() method.
							return function() {
								subscribed = false;
							}
						})
					},
					NOOP = function() {};

				fun(
					{
						addEventListener: function(event, handler) {
							window.setTimeout(handler, 200)
						},
						removeEventListener: NOOP
					},
					getJSON,
					function(output) { alert(JSON.stringify(output)) },
					function(output) { alert(output) });
			}
		</pre>
		<div class="post">
			<p>Almost every workflow in a web application starts with an event, continues with an HTTP request, and results
				in a state change. Now we know how to express the first two tasks elegantly.</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 38: Throttle Input</h4>

		<p>When dealing with user input, there will be times when the user's input is too noisy, and will potentially clog
			your servers with extraneous requests. We want the ability to throttle the users's input so that if they
			interacting for one second, then we will get the user input. Let's say for example, the user clicks a button
			once too many times upon saving and we only want to fire after they've stopped for a second.</p>
		<pre>
			seq([1,2,3,,,,,,,4,5,6,,,]).throttle(1000 /* ms */) === seq([,,,,,,,3,,,,,,,,,,6,,,]);
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (clicks, saveData, name) {
				return clicks.
					// TODO: Throttle the clicks so that it only happens every one second
					concatMap(function () {
						return saveData(name);
					});
			}
		</textarea>

		<button class="go">运行</button>
		<label for="inputName">Name</label>
		<input type="text" class="inputName"><strong class="savedValue"></strong>
		<button class="submitInputName">Save</button> <<-- Click this to save your data

		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var $inputName = $('.inputName', lesson),
					$savedValue = $('.savedValue', lesson);

				var counter = 0;
				var data = null;
				var clicks = Observable.fromEvent($('.submitInputName', lesson)[0], 'click');

				var code =  eval("(" + str + ")")
				var code = code(clicks, function(name) { return Rx.Observable.returnValue(name.val()); }, $inputName);

				code
					.subscribe(function (data) {
						$savedValue.text('Name Saved: ' + data);
					});
			}
		</pre>
        <pre class="answer">
			function (clicks, saveData, name) {
				return clicks.
					throttle(1000).
					concatMap(function () {
						return saveData(name);
					})
			}
        </pre>
		<div class="post">
			<p>Now that we know how to throttle input, let's take a look at another problem where throttling data is
				important...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 39: Autocomplete Box</h4>

		<p>One of the most common problems in web development is the autocomplete box. This seems like it should be an easy
			problem, but is actually quite challenging. For example, how do we throttle the input? How do we make sure we're
			not getting out of order requests coming back? For example if I type "react" then type "reactive" I want
			"reactive" to be my result, regardless of which actually returned first from the service.</p>

		<p>In the example below, you will be receiving a sequence of key presses, a textbox, and a function when called
			returns an array of search results.</p>
		<pre>
			getSearchResultSet('react') === seq[,,,["reactive", "reaction","reactor"]]
			keyPresses === seq['r',,,,,'e',,,,,,'a',,,,'c',,,,'t',,,,,]
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (getSearchResultSet, keyPresses, textBox) {

				var getSearchResultSets =
					keyPresses.
					map(function () {
						return textBox.value;
					}).
					// TODO: Ensure that we only trigger a maximum of one search request per second
					concatMap(function (text) {

					// TODO: Ensure this sequence ends as soon as another key press arrives
					return getSearchResultSet(text);
				});

				return getSearchResultSets;
			}
		</textarea>

		<button class="go">运行</button>

		<label for="inputName">Name</label>
		<input type="text" class="inputName">

		<ul class="searchResultsForAutoComplete"></ul>

		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var wordlist = window.wordlist;
				wordlist.sort();

				var searchText = function (text) {

					var matched = wordlist.filter(function (x) {
						return x.indexOf(text) === 0;
					});

					return Rx.Observable.returnValue(
						matched.slice(0, 10)
					);
				};

				var $inputName = $('.inputName', lesson)[0],
					$searchResults = $('.searchResultsForAutoComplete', lesson);

				var clicks = Rx.Observable.fromEvent($inputName, 'keyup');

				var code =  eval("(" + str + ")")
				var code = code(searchText, clicks, $inputName);

				code
					.subscribe(function (results) {
						var s = results.map(function (r) {
							return '&lt;li&gt;' + r + '&lt;/li&gt;';
						});
						$searchResults.html(s.join(''));
					});
			}
		</pre>
        <pre class="answer">
			function (getSearchResultSet, keyPresses, textBox) {

				var getSearchResultSets =
					keyPresses.
						map(function () {
							return textBox.value;
						}).
						throttle(1000).
						concatMap(function (text) {
							return getSearchResultSet(text).takeUntil(keyPresses);
						});

				return getSearchResultSets;
			}
        </pre>
		<div class="post">
			<p>Now that we're able to query with our throttled input, you'll still notice one slight problem. If you hit
				your arrow keys or any other non character key, the request will still fire. How do we prevent that?</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 40: Distinct Until Changed Input</h4>

		<p>You'll notice in the previous exercise that if you pressed your arrow keys while inside the textbox, the query
			will still fire, regardless of whether the text actually changed or not. How do we prevent that? The
			distinctUntilChanged filters out successive repetitive values.</p>
		<pre>
			seq([1,,,1,,,3,,,3,,,5,,,1,,,]).distinctUntilChanged() ===
			seq([1,,,,,,,3,,,,,,,5,,,1,,,]);
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (keyPresses, isAlpha) {

				return keyPresses.
					map(function (e) { return String.fromCharCode(e.keyCode); }).

					// Ensure we only have alphabetic characters
					filter(function (character) { return isAlpha(character); }).

					// TODO: Filter out successive repetitive keys

					// Building up a string of all the characters typed.
					scan('', function (stringSoFar, character) {
						return stringSoFar + character;
					});
			}
		</textarea>

		<button class="go">运行</button>

		<label for="inputName">Enter Keys</label>
		<input type="text" class="inputName">
		<div>Keys filtered by distinctUntilChanged: <strong class="filteredKeysByDistinct"></strong></div>
		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var $inputName = $('.inputName', lesson),
					$filtered = $('.filteredKeysByDistinct', lesson);

				var keyups = Rx.Observable.fromEvent($inputName[0], 'keypress');

				var isAlpha = function (x) {
					return 'abcdefghijklmnopqrstuvwxyz'.indexOf(x.toLowerCase()) !== -1;
				};

				var code =  eval("(" + str + ")")
				var code = code(keyups, isAlpha);

				code
					.subscribe(function (text) {
						$filtered.text(text);
					});
			}
		</pre>
        <pre class="answer">
			function (keyPresses, isAlpha) {

				return keyPresses.
					map(function (e) { return String.fromCharCode(e.keyCode); }).
					filter(function (character) { return isAlpha(character); }).
					distinctUntilChanged().
					scan('', function (stringSoFar, character) {
						return stringSoFar + character;
					});
			}
        </pre>
		<div class="post">
			<p>Now that we know how to get only the distinct input, let's see how it applies to our autocomplete
				example...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 41: Autocomplete Box Part 2: Electric Boogaloo</h4>

		<p>In the previous version of the autocomplete box, there were two bugs</p>
		<ul>
			<li>Multiple successive searches are made for the same string</li>
			<li>Attempts are made to retrieve results for an empty string.</li>
		</ul>

		<p>The example below is the same as above, but this time, fix the bugs!</p>
		<pre>
			getSearchResultSet('react') === seq[,,,["reactive", "reaction","reactor"]]
			keyPresses === seq['r',,,,,'e',,,,,,'a',,,,'c',,,,'t',,,,,]
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (getSearchResultSet, keyPresses, textBox) {

				var getSearchResultSets =
					keyPresses.
						map(function () {
							return textBox.value;
						}).
						throttle(1000).

						// TODO: Make sure we only get distinct values

						// TODO: Make sure the text is not empty

						concatMap(function (text) {
							return getSearchResultSet(text).takeUntil(keyPresses);
						});

				return getSearchResultSets;
			}
		</textarea>

		<button class="go">运行</button>
		<label for="inputName">Name</label>
		<input type="text" class="inputName">

		<ul class="searchResultsForAutoComplete"></ul>
		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var wordlist = window.wordlist;
				wordlist.sort();

				var searchText = function (text) {

					var matched = wordlist.filter(function (x) {
						return x.indexOf(text) === 0;
					});

					return Rx.Observable.returnValue(
						matched.slice(0, 10)
					);
				};

				var $inputName = $('.inputName', lesson),
					$searchResults = $('.searchResultsForAutoComplete', lesson);

				var clicks = Rx.Observable.fromEvent($inputName[0], 'keyup');

				var code =  eval("(" + str + ")")
				var code = code(searchText, clicks, $inputName[0]);

				code
					.subscribe(function (results) {
						var s = results.map(function (r) {
							return '&lt;li&gt;' + r + '&lt;/li&gt;';
						});
						$searchResults.html(s.join(''));
					});
			}
		</pre>
        <pre class="answer">
			function (getSearchResultSet, keyPresses, textBox) {

				var getSearchResultSets =
					keyPresses.
						map(function () {
							return textBox.value;
						}).
						throttle(1000).
						distinctUntilChanged().
						filter(function (s) { return s.length > 0; }).
						concatMap(function (text) {
							return getSearchResultSet(text).takeUntil(keyPresses);
						});

				return getSearchResultSets;
			}
        </pre>
		<div class="post">
			<p>With just this little amount of code, we're able to produce a fully functioning autocomplete scenario. But
				there are other outstanding questions, such as error handling. How can we handle failure and retry if
				necessary?</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 42: Retrying after errors</h4>

		<p>You'll notice in the previous exercise that if you pressed your arrow keys while inside the textbox, the query
			will still fire, regardless of whether the text actually changed or not. How do we prevent that? The
			distinctUntilChanged filters out successive repetitive values.</p>
		<pre>
			seq([1,,,1,,,3,,,3,,,5,,,1,,,]).distinctUntilChanged() ===
			seq([1,,,,,,,3,,,,,,,5,,,1,,,]);
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (keyPresses, isAlpha) {

				return keyPresses.
					map(function (e) { return String.fromCharCode(e.keyCode); }).

					// Ensure we only have alphabetic characters
					filter(function (character) { return isAlpha(character); }).

					// TODO: Filter out successive repetitive keys

					// Building up a string of all the characters typed.
					scan('', function (stringSoFar, character) {
						return stringSoFar + character;
					});
			}
		</textarea>

		<button class="go">运行</button>

		<label for="inputName">Enter Keys</label>
		<input type="text" class="inputName">

		<div>Keys filtered by distinctUntilChanged</div>
		<div class="filteredKeysByDistinct"></div>

		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var $inputName = $('.inputName', lesson),
					$filtered = $('.filteredKeysByDistinct', lesson);

				var keyups = Rx.Observable.fromEvent($inputName[0], 'keyup');

				var isAlpha = function (x) {
					return 'abcdefghijklmnopqrstuvwxyz'.indexOf(x.toLowerCase()) !== -1;
				};

				var code =  eval("(" + str + ")")
				var code = code(keyups, isAlpha);

				code
					.subscribe(function (text) {
						$filtered.text(text);
					});
			}
		</pre>
        <pre class="answer">
			function (keyPresses, isAlpha) {

				return keyPresses.
					map(function (e) { return String.fromCharCode(e.keyCode); }).
					filter(function (character) { return isAlpha(character); }).
					distinctUntilChanged().
					scan('', function (stringSoFar, character) {
						return stringSoFar + character;
					});
			}
        </pre>
		<div class="post">
			<p>Now that we know how to get only the distinct input, let's see how it applies to our autocomplete example...</p>

			<h1>A Work in Progress</h1>

			<p>Congratulations! You've made it this far, but you're not done. Learning is an on-going process. Go out and start
				using the functions you've learned in your day-to-day coding. Over time, I'll be adding more exercises to this
				tutorial. If you have suggestions for more exercises, send me a pull request!
			</p>
		</div>
	</div>
    <div class="modal hide" id="modalGetJSON">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                            aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title">Enter your answer JSON below</h4>
                </div>
                <div class="modal-body">
                    <form>
                        <textarea name="answerText" has-value="true" style="margin: 0px 0px 10px; height: 165px; width: 526px;resize: none"></textarea>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary save-btn" data-dismiss="modal">Save changes</button>
                </div>
            </div>
            <!-- /.modal-content -->
        </div>
        <!-- /.modal-dialog -->
    </div>
	<div class="modal hide" id="modalShowJSON">
		<div class="modal-dialog">
			<div class="modal-content">
				<div class="modal-header">
					<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
							aria-hidden="true">&times;</span></button>
					<h4 class="modal-title">Ctrl-C your answer JSON below</h4>
				</div>
				<div class="modal-body">
					<form>
						<textarea name="answerText" readonly="readonly" has-value="true" style="margin: 0px 0px 10px; height: 165px; width: 526px;resize: none"></textarea>
					</form>
				</div>
				<div class="modal-footer">
					<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
				</div>
			</div>
			<!-- /.modal-content -->
		</div>
		<!-- /.modal-dialog -->
	</div>
</div>

<script src="assets/app/wordlist.js"></script>
<script src="assets/codemirror/codemirror.js"></script>
<script src="assets/app/javascript.js"></script>

<script src="assets/rx/rx.all.js"></script>

<script src="assets/jquery/jquery-1.10.2.min.js"></script>
<script src="assets/bootstrap/js/bootstrap.min.js"></script>
<script src="assets/app/grab_answers.js"></script>
<script src="assets/app/show_answers.js"></script>

<script src="assets/app/utils.js"></script>
<script src="assets/app/main.js"></script>
<script type="text/javascript">

	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-37739914-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script');
		ga.type = 'text/javascript';
		ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(ga, s);
	})();

</script>
</body>
</html>
