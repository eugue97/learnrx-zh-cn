<html>
<head>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/codemirror/codemirror.css">
	<link rel="stylesheet" href="assets/app/site.css">
	<meta charset="UTF-8">
	<title>Javascript 函数式编程</title>
	<script type="text/javascript">
		// Adds the implementation for Array.prototype.concatAll()
		function defineConcatAll() {
			Array.prototype.concatAll = function () {
				var results = [];

				this.forEach(function(subArray) {
					results.push.apply(results, subArray);
				});

				return results;
			};
		}

		/**
		 * Add the implementation for Array.prototype.concatMap()
		 */
		function defineConcatMap() {
			Array.prototype.concatMap = function(fnc) {
				return this.
					map(function (e) {
						return fnc(e);
					}).
					// apply the concatAll function to flatten the two-dimensional array
					concatAll();
			};
		}

		/**
		 * This function will be executed at the begining of each verifier function
		 */
		function preVerifierHook() {
			// Add helpers to prevent 'undefined is not a function' like errors
			defineConcatAll();
			defineConcatMap();
		}
	</script>
</head>
<body>
<div class="content">
	<div class="grab-answers">
		<p>这是一套附带练习的交互式教程，你可以直接在浏览器中完成。<b>如果你只是想看到教程内容，点击下面的按钮</b>：</p>
		<button class="green-button show-answers">显示所有答案</button>
	</div>
	<h1 class="center">Javascript 函数式编程</h1>

	<p>这是一套用于学习使用微软 Reactive Extensions(Rx) Javascript 库的交互式学习教程。那为什么标题要叫做“Javascript 函数式编程”呢？因为学习 Rx 的关键，就是要训练自己去使用函数式的编程方法，进行各种集合操作。函数式编程可以让开发者把常见的集合操作，抽象成一个个可重用的，可组合的代码块。你会惊讶的发现，绝大部分集合操作都可以用下面这<b>五个简单的函数</b>来实现（有些函数是 Javascript 原生自带的，有些包含在 <a href="https://github.com/Reactive-Extensions/RxJS">RxJS library</a> 里面）：
	</p>
	<ol>
		<li>map</li>
		<li>filter</li>
		<li>concatAll</li>
		<li>reduce</li>
		<li>zip</li>
	</ol>

	<p>我向你打包票，如果你掌握了这五个函数，你的代码会变得更精简，更有表达能力，而且更易于维护。而且，现在看起来可能不是很明显，但是实际上这五个函数式简化异步编程的关键。当你完成了这个教程之后，你就也掌握了必要的方法，可以做到避免竞态，传播和处理异步错误，处理串行的事件和 AJAX 请求等等。一句话，<b>这五个函数可能是你这辈子学到的所有函数中最强大，最灵活，最有用的</b>。
	</p>

	<h2>完成交互式练习</h2>

	<p>这个教程不仅仅是一个教程，它包含了<b>一系列的交互式练习，你只需要浏览器就可以完成。</b>完成练习的步骤很简单，只需要编辑代码，然后点击“运行”，如果代码可以工作，新的练习就会出现在下面，反之则会弹出错误提示。
	</p>
	<p><b>提示：</b>使用 "F4" 键可以打开编辑器的全屏模式</p>

	<p>这个教程可能存在 bug，如果你碰到了什么诡异的情况，或者你觉得已经输入了正确答案但是还是不能继续向下进行，就刷新一下浏览器试试。如果你使用的是现代浏览器（你都来到这里了，我相信你肯定不是用的 IE6），练习的状态会被保存到本地。如果你需要的话，可以<a href="javascript:localStorage.newState = ''; document.location.reload();">重启这个教程</a>。</p>

	<p>这个教程托管在 <a href="https://github.com/ReactiveX/learnrx">Github</a> 上, 处于一个正在逐渐被完善的阶段，如果你想添加新的练习，完善已有练习的问题描述，或者解决某个 bug，都可以 <a href="https://github.com/ReactiveX/learnrx/fork">fork</a> 这个项目，然后发送 pull request。我们会试着把用户贡献的问题融合到已有的教程当中。
	</p>
	<div class="grab-answers">
		<p>你的答案会被存储到 local storage 当中。 如果你想把答案转移到另外的位置，使用下面的按钮进行操作：</p>
		<button class="green-button get-answer">把答案导出为 JSON</button>
		<button class="blue-button set-answer">导入 JSON 答案</button>
	</div>

	<h2>操作数组</h2>

	<p>在 Javascript 中，数组是唯一的集合类型，几乎写任何程序都需要用到数组。接下来我们要把上面提到的五个函数，加入到数组类型，让数组类型变得更加强大易用。实际上，Javascript 的数组类型已经自带了 map，filter 和 reduce 这三个函数了！不过我们还是要把他们重新实现一遍，作为练习的一部分。</p>

	<p>下面教程的过程是这样的，首先我们使用你在学校学过的方法（或者在别人代码中看到的方法）解决问题，也就是使用循环和赋值语句，把一个集合转换为另一个集合。然后我们实现上面提到的五个函数中的某一个，接下来使用这个函数<i>在不使用循环的情况下</i>解决相同的问题。当你把五个函数全部掌握之后，你会学习如何把他们结合起来，在不需要太多的代码的情况下，解决更加复杂的问题。</p>

	<h3>遍历数组</h3>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson" style="visibility: visible">
		<h4>练习 1: 打印数组中所有的名字</h4>
		<textarea class="code" rows="8" cols="80">
			function(console) {
				var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"],
					counter;

				for(counter = 0; counter < names.length; counter++) {
					console.log(names[counter]);
				}
			}
		</textarea>
		<button class="go">运行</button>
		<span class="aside">&lt;- 点这里来执行你的代码，如果结果正确，就可以继续下一个练习</span>

		<div class="output"></div>

		<pre class="verifier">
			// Traverse array with for loop
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")");
				var items = [];
				var got;
				var expected = '["Ben","Brian","Jafar","Matt","Priya"]';
				fun({
					log:function(name) {
						items.push(name);
						console.log(name);
					}
				});

				got = JSON.stringify(items.sort());
				if(got === expected) {
					return "成功!"
				}
				else {
					showLessonErrorMessage(expected, got, '注意：输出顺序没有关系');
				}
			}
		</pre>
		<pre class="answer">
			function(console) {
				var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"],
					counter;

				for(counter = 0; counter < names.length; counter++) {
					console.log(names[counter]);
				}
			}
		</pre>
		<p class="post">思考这个问题： <b>我们需要确定数组打印的<i>顺序</i>吗？</b>如果不需要，那么为什么需要循环呢？</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 2: 使用 forEach 打印数组中所有的名字</h4>
		<p>我们使用 forEach 函数重做上面的练习。</p>

		<textarea class="code" rows="8" cols="80">
			function(console) {
				var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"];

				names.forEach(function(name) {
					console.log(name);
				});
			}
		</textarea>
		<button class="go">运行</button>

		<div class="output"></div>

		<pre class="verifier">
			// Traverse array with foreach
			function(str) {
				preVerifierHook();
				if (str.indexOf(".forEach") === -1) {
					return "You have to use forEach!"
				}
				var fun = eval("(" + str + ")");
				var items =[];
				fun({
					log:function(name) {
						items.push(name);
						console.log(name);
					}
				});
				if(JSON.stringify(items.sort()) === '["Ben","Brian","Jafar","Matt","Priya"]') {
					return "Success!"
				}
				else {
					throw 'console.log 没有输出下面这些值: "Ben","Brian","Jafar","Matt","Priya" (注意：顺序没有关系)'
				}
			}
		</pre>

    	<pre class="answer">
			function(console) {
				var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"];

				names.forEach(function(name) {
					console.log(name);
				});
			}
    	</pre>
		<div class="post">
			<p>
				注意到一点，forEach 允许我们指明我们想要使用数组中的元素做些<i>什么</i>, 但是隐藏了数组是<i>怎么样</i>被遍历的细节.
			</p>
			<h3>投影数组</h3>
			<p>对某个值执行一个函数，以得到新的值，这种操作叫做<i>投影</i>。为了把一个数组投影成另一个数组，我们对数组中的每个元素都执行一个投影函数，然后把所有的结果收集起来，组成新的数组。
			</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 3: 使用 forEach 函数把一个包含 video 信息的数组投影成包含 {id,title} 对的新数组</h4>

		<p>对于每一个 video, 添加一个 {id, title} 对到 videoAndTitlePairs 数组。</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var newReleases = [
					{
						"id": 70111470,
						"title": "Die Hard",
						"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [4.0],
						"bookmark": []
					},
					{
						"id": 654356453,
						"title": "Bad Boys",
						"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [5.0],
						"bookmark": [{ id:432534, time:65876586 }]
					},
					{
						"id": 65432445,
						"title": "The Chamber",
						"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [4.0],
						"bookmark": []
					},
					{
						"id": 675465,
						"title": "Fracture",
						"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [5.0],
						"bookmark": [{ id:432534, time:65876586 }]
					}
				],
				videoAndTitlePairs = [];

				// ------------ 在这里写下答案 -----------------------------------
				// 使用 forEach 函数从 video 中拿到 {id, title}，使用 push() 方法把
				// 结果放到 videoAndTitlePairs 数组中。
				// 例如 videoAndTitlePairs.push(newItem);
				// ------------ 在这里写下答案 -----------------------------------


				return videoAndTitlePairs;
			}
		</textarea>

		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>

		<div class="output"></div>

		<pre class="verifier">
			// Projection with with forEach
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videoAndTitlePairs = fun(),
					expected = '[{\"id\":675465,\"title\":\"Fracture\"},{\"id\":65432445,\"title\":\"The Chamber\"},{\"id\":70111470,\"title\":\"Die Hard\"},{\"id\":654356453,\"title\":\"Bad Boys\"}]';

				// Sorting by video id
				videoAndTitlePairs = videoAndTitlePairs.sortBy(function(video) { return video.id });
				if (JSON.stringify(videoAndTitlePairs) === expected) {
					return true;
				}
				else {
					showLessonErrorMessage(expected, JSON.stringify(videoAndTitlePairs));
				}
			}
    	</pre>
        <pre class="answer">
			function() {
				var newReleases = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [4.0],
							"bookmark": []
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [5.0],
							"bookmark": [{ id:432534, time:65876586 }]
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [4.0],
							"bookmark": []
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [5.0],
							"bookmark": [{ id:432534, time:65876586 }]
						}
					],
					videoAndTitlePairs = [];

				newReleases.forEach(function(video) {
					videoAndTitlePairs.push({id:video.id, title: video.title});
				});

				return videoAndTitlePairs;
			}
		</pre>
		<div class="post">
			<p>所有的数组投影都需要完成下面两个操作</p>
			<ol>
				<li>遍历源数组</li>
				<li>把每个元素投影之后的结果添加到新数组</li>
			</ol>
			<p>既然如此，我们为什么不直接把<i>怎么样</i>执行这些操作的细节隐藏起来呢？</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 4: 实现 map()</h4>

		<p>为了让投影操作变得更简单，我们给数组类型添加一个<b>map()</b>方法。Map 函数接受一个投影函数作为参数，对源数组的每个对象都应用这个函数，然后返回投影后的数组。
		</p>

		<textarea class="code" rows="20" cols="80">
			Array.prototype.map = function(projectionFunction) {
				var results = [];
				this.forEach(function(itemInArray) {

					// ------------ 在这里写下答案 ----------------------------
					// 对数组中的每一个元素使用 projectionFunction 方法，并把结果放到
					// 一个数组里面。
					// 注意: 你可以使用 push() 方法把元素放到数组中。
					// ------------ 在这里写下答案 ----------------------------

				});

				return results;
			};

			// JSON.stringify([1,2,3].map(function(x) { return x + 1; })) === '[2,3,4]'
		</textarea>

		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>

		<div class="output"></div>

		<pre class="verifier">
			// Implement map()
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					arr = [1,2,3],
					result;

				result = arr.map(function(x) { return x + 1});

				if (JSON.stringify(arr) !== "[1,2,3]") {
					throw "喔! 你改变了源数组的值。Map 不应该改变输入数组的值，它应该对输入数组的每个元素执行投影函数之后，返回一个新的数组"
				}
				else if(JSON.stringify(result) !== '[2,3,4]') {
					throw '[1,2,3].map(function(x) { return x + 1}) 结果应该为 [2,3,4].'
				}
			}
		</pre>
		<pre class="answer">
			Array.prototype.map = function(projectionFunction) {
				var results = [];
				this.forEach(function(itemInArray) {
					results.push(projectionFunction(itemInArray));
				});

				return results;
			};

			// JSON.stringify([1,2,3].map(function(x) { return x + 1; })) === '[2,3,4]'
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 5: 使用 map() 把一个 videos 数组投影成 {id,title} 对数组</h4>

		<p>我们来重复上面的收集 {id, title} 对得到一个新数组的练习，<b>这次使用 map 函数来完成</b>。
		</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var newReleases = [
					{
						"id": 70111470,
						"title": "Die Hard",
						"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [4.0],
						"bookmark": []
					},
					{
						"id": 654356453,
						"title": "Bad Boys",
						"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [5.0],
						"bookmark": [{ id:432534, time:65876586 }]
					},
					{
						"id": 65432445,
						"title": "The Chamber",
						"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [4.0],
						"bookmark": []
					},
					{
						"id": 675465,
						"title": "Fracture",
						"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": [5.0],
						"bookmark": [{ id:432534, time:65876586 }]
					}
				];

				// ------------ 在这里写下答案 -----------------------------------
				// 使用 map 方法拿到每个 video 当中的 {id, title}。
				return newReleases.map // 完成这个语句。
				// ------------ 在这里写下答案 -----------------------------------

			}
		</textarea>

		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Projection with map
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videoAndTitlePairs = fun(),
					expected = '[{\"id\":675465,\"title\":\"Fracture\"},{\"id\":65432445,\"title\":\"The Chamber\"},{\"id\":70111470,\"title\":\"Die Hard\"},{\"id\":654356453,\"title\":\"Bad Boys\"}]';

				// Sorting by video id
				videoAndTitlePairs = videoAndTitlePairs.sortBy(function(video) { return video.id });
				if (JSON.stringify(videoAndTitlePairs) === expected) {
					return true;
				}
				else {
					throw 'Expected: ' + expected;
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var newReleases = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [4.0],
							"bookmark": []
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [5.0],
							"bookmark": [{ id:432534, time:65876586 }]
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [4.0],
							"bookmark": []
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": [5.0],
							"bookmark": [{ id:432534, time:65876586 }]
						}
					];

			  return newReleases.map(function(video) { return {id: video.id, title: video.title}; });
			}
		</pre>
		<div class="post">
			<p>注意到，map 允许我们指明我们想要对数组施加<i>什么</i>投影操作, 但是隐藏了这个操作是
				<i>怎么样</i>被执行的细节。
			</p>
			<h3>过滤数组</h3>
			<p>和投影类似，过滤（filter）数组也是很常见的操作。过滤一个数组是这样的过程，我们对数组中的每个元素都执行一个检查，然后把所有通过这个检查的元素收集成一个新的数组。
			</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 6: 使用 forEach() 收集那些评分（rating) 为 5.0 的 video</h4>

		<p>使用 forEach() 遍历 newReleases 数组, 如果一个 video 评分为 5.0, 就把它添加到 videos 数组.
		</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var newReleases = [
					{
						"id": 70111470,
						"title": "Die Hard",
						"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 4.0,
						"bookmark": []
					},
					{
						"id": 654356453,
						"title": "Bad Boys",
						"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 5.0,
						"bookmark": [{ id:432534, time:65876586 }]
					},
					{
						"id": 65432445,
						"title": "The Chamber",
						"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 4.0,
						"bookmark": []
					},
					{
						"id": 675465,
						"title": "Fracture",
						"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 5.0,
						"bookmark": [{ id:432534, time:65876586 }]
					}
				],
				videos = [];

				// ------------ 在这里写下答案 -----------------------------------
				// 使用 forEach 方法拿到所有 rating 为 5.0 的 video。
				// ------------ 在这里写下答案 -----------------------------------

				return videos;
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Filter with forEach
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					expected = '[{"id":675465,"title":"Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture.jpg","uri":"http://api.netflix.com/catalog/titles/movies/70111470","rating":5,"bookmark":[{"id":432534,"time":65876586}]},{"id":654356453,"title":"Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys.jpg","uri":"http://api.netflix.com/catalog/titles/movies/70111470","rating":5,"bookmark":[{"id":432534,"time":65876586}]}]';

				// Sorting by video id
				videos = videos.sortBy(function(v) { return v.id; });
				if (JSON.stringify(videos) === expected) {
					return true;
				}
				else {
					throw 'Expected: ' + expected;
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var newReleases = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
							"bookmark": []
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
							"bookmark": [{ id:432534, time:65876586 }]
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
							"bookmark": []
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
							"bookmark": [{ id:432534, time:65876586 }]
						}
					],
					videos = [];

				newReleases.forEach(function(video) {
					if (video.rating === 5.0) {
						videos.push(video);
					}
				});

				return videos;
			}
		</pre>

		<div class="post">
			<p>注意，和 map() 类似, <b>每个 filter() 操作也都要完成下面的操作</b>:</p>
			<ol>
				<li>遍历数组</li>
				<li>把通过测试的元素加入到新数组</li>
			</ol>
			<p>为什么我们不把这些实现细节也隐藏起来呢？</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 7: 实现 filter()</h4>

		<p>为了让过滤操作更简单, 我们给数组类型添加一个 filter() 函数。 filter() 接受一个<i>断言</i>作为参数。
			断言是这样一个函数： 它以数组中的一个元素作为参数，返回一个布尔值，表明这个元素应不应该被添加到新数组中。</p>

		<textarea class="code" rows="20" cols="80">
			Array.prototype.filter = function(predicateFunction) {
				var results = [];
				this.forEach(function(itemInArray) {
					// ------------ 在这里写下答案 ----------------------------
					// 对数组中的每个元素执行 predicateFunction 方法。如果返回为 true 就
					// 把它添加到结果数组中。
					// 注意: 你可以使用 push() 方法把元素放到数组中。
					// ------------ 在这里写下答案 ----------------------------
				});

				return results;
			};

			// JSON.stringify([1,2,3].filter(function(x) { return x > 2})) === "[3]"
		</textarea>

		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Implement filter()
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					arr = [1,2,3],
					result;

				result = arr.filter(function(x) { return x > 2});

				if (JSON.stringify(arr) !== "[1,2,3]") {
					throw "喔! 你改变了源数组的值。Filter 不应该改变输入数组的值，它应该对输入数组的每个元素执行投影函数之后，返回一个新的数组"
				}
				else if(JSON.stringify(result) !== '[3]') {
					throw '[1,2,3].filter(function(x) { return x > 2}) 结果应该为 [3].'
				}
			}
		</pre>
		<pre class="answer">
			Array.prototype.filter = function(predicateFunction) {
				var results = [];
				this.forEach(function(itemInArray) {
				  if (predicateFunction(itemInArray)) {
					results.push(itemInArray);
				  }
				});

				return results;
			};

			// JSON.stringify([1,2,3].filter(function(x) { return x > 2})) === "[3]"
		</pre>
		<p class="post">和 map() 类似, filter() 让我们选择想要<i>什么</i>数据，但是不要求我们指明<i>怎么样</i>去收集这些数据。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>使用链式调用来查询数据</h3>
		<h4>练习 8: 链式调用 filter 和 map，收集 video 当中 rating 为 0.5 的那些 video 的 id。</h4>
		<textarea class="code" rows="60" cols="80">
			function() {
				var newReleases = [
					{
						"id": 70111470,
						"title": "Die Hard",
						"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 4.0,
						"bookmark": []
					},
					{
						"id": 654356453,
						"title": "Bad Boys",
						"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 5.0,
						"bookmark": [{ id:432534, time:65876586 }]
					},
					{
						"id": 65432445,
						"title": "The Chamber",
						"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 4.0,
						"bookmark": []
					},
					{
						"id": 675465,
						"title": "Fracture",
						"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
						"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
						"rating": 5.0,
						"bookmark": [{ id:432534, time:65876586 }]
					}
				];

				// ------------ 在这里写下答案 -----------------------------------
				// 结合 filter 和 map 方法，拿到所有 rating 为 5.0 的 video 的 id。
				return newReleases // 完成这个语句
				// ------------ 在这里写下答案 -----------------------------------
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Filter with filter()
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videoids = fun(),
					expected = '[675465,654356453]';

				// Sorting by video id
				videoids = videoids.sortBy(function(v) { return v; });
				if (JSON.stringify(videoids) === expected) {
					return true;
				}
				else {
					throw 'Expected: ' + expected;
				}
			}
			</pre>
		<pre class="answer">
			function() {
				var newReleases = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
							"bookmark": []
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
							"bookmark": [{ id:432534, time:65876586 }]
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
							"bookmark": []
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
							"bookmark": [{ id:432534, time:65876586 }]
						}
					];

				// ------------   在这里写下答案   -----------------------------------
				// 结合 filter 和 map 方法，拿到所有 rating 为 5.0 的 video 的 id。


				return newReleases.
					filter(function(video) {
						return video.rating === 5.0;
					}).
					map(function(video) {
						return video.id;
					});
				// ------------   在这里写下答案  -----------------------------------
			}
		</pre>

		<p class="post">把 map() 和 filter() 结合在一起调用，让我们的代码变得富有表现力。 这些高层函数让我们表达我们想要
<i>什么</i>数据， 使得下层库在处理<i>怎么样</i>执行查询操作时可以有很大的灵活性。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>查询树</h3>
		<p>有时候，除了数组之外，我们还需要对树状数据结构进行查询。树带来了一个新的问题，因为我们需要首先把数展开成数组，然后才能使用 filter() 和 map() 操作。在这个部分的练习中，我们定义了 concatAll() 函数，结合它我们就可以使用 map() 和 filter 对树进行查询了。</p>

		<h4>练习 9: 把 movieLists 数组展开成包含 video 的 id 的数组</h4>

		<p>首先，我们使用两层嵌套的 forEach 循环，把二维数组 movieLists 中所有 video 的 id 收集起来。</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
					{
						name: "New Releases",
						videos: [
							{
								"id": 70111470,
								"title": "Die Hard",
								"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
								"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 654356453,
								"title": "Bad Boys",
								"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
								"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					},
					{
						name: "Dramas",
						videos: [
							{
								"id": 65432445,
								"title": "The Chamber",
								"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
								"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 675465,
								"title": "Fracture",
								"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
								"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					}
				],
				allVideoIdsInMovieLists = [];

				// ------------   在这里写下答案  -----------------------------------
				// 使用两层嵌套的 forEach 循环，把 movieLists 打平成一个 video id 的列表。
				// ------------   在这里写下答案  -----------------------------------

				return allVideoIdsInMovieLists;

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Use filter and map to collect video ids with rating of 5.0
			function(str) {
				var fun = eval("(" + str + ")"),
					videos = fun(),
					expected = '[675465,65432445,70111470,654356453]';

				videos = videos.sortBy(function(v) { return v });
				if (JSON.stringify(videos) !== expected) {
					throw "Expected " + expected;
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "Dramas",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					],
					allVideoIdsInMovieLists = [];

				movieLists.forEach(function(movieList) {
					movieList.videos.forEach(function(video) {
						allVideoIdsInMovieLists.push(video.id);
					});
				});

				return allVideoIdsInMovieLists;

			}
		</pre>

		<p class="post">用 forEach 来展开数组很简单，因为我们可以显式地把元素添加到新数组中。可惜，这恰恰就是我们想通过类似 map()，filter() 这种函数来封装起来的底层操作。我们能不能定义一个方法，使它足够抽象，允许我们指明想要展开一个树的<i>意图</i>，但是不需要指明<i>怎么样</i>完成这个操作？</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 10: 实现 concatAll()</h4>

		<p>我们给数组类型增加一个 concatAll() 方法。 concatAll() 会遍历数组中的每一个子数组，把它们的结果收集到一个新的，展开的数组当中。 注意<b> concatAll() 方法需要数组中的每一个元素也都是一个数组</b>。
		</p>

		<textarea class="code" rows="20" cols="80">
			Array.prototype.concatAll = function() {
				var results = [];
				this.forEach(function(subArray) {
					// ------------ 在这里写下答案 ----------------------------
					// 把每个子数组中元素添加到结果数组当中。
					// ------------ 在这里写下答案 ----------------------------
				});

				return results;
			};

			// JSON.stringify([ [1,2,3], [4,5,6], [7,8,9] ].concatAll()) === "[1,2,3,4,5,6,7,8,9]"
			// [1,2,3].concatAll(); // throws an error because this is a one-dimensional array
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			// Flatten movieLists into an array of video ids
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					arr = [[1,2,3],[4,5,6],[7,8,9]],
					result,
					expected = "[1,2,3,4,5,6,7,8,9]";

				result = arr.concatAll();
				result = result.sortBy(function(x) { return x; });
				if (JSON.stringify(result) !== expected) {
					throw 'Expected that [[1,2,3],[4,5,6],[7,8,9]].concatAll() would equal [1,2,3,4,5,6,7,8,9].'
				}
			}
		</pre>
		<pre class="answer">
			Array.prototype.concatAll = function() {
				var results = [];
				this.forEach(function(subArray) {
					results.push.apply(results, subArray);
				});

				return results;
			};

			// JSON.stringify([ [1,2,3], [4,5,6], [7,8,9] ].concatAll()) === "[1,2,3,4,5,6,7,8,9]"
			// [1,2,3].concatAll(); // throws an error because this is a one-dimensional array
		</pre>
		<p class="post">concatAll 函数非常简单，简单到你可能都不太会注意到它如何与 map() 结合起来，进行树的查询，我们来举一个例子。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 11: 使用 map() 和 concatAll() 对 movieLists 进行投影和展开，获取包含所有 video 的 id 的数组</h4>

		<p>提示: 使用两个嵌套的 map() 和一个 concatAll()。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "Dramas",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];

				// ------------  在这里写下答案  -----------------------------------
				// 使用 map 和 concatAll 把 movieLists 打平成 video id 的数组。
				// ------------  在这里写下答案  -----------------------------------

				return movieLists // 完成这个语句

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					expected = '[675465,65432445,70111470,654356453]';

				videos = videos.sortBy(function(v) { return v });
				if (JSON.stringify(videos) !== expected) {
					throw "Expected " + expected + "\n\nReceived " + JSON.stringify(videos);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "Dramas",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
									"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];

				// ------------  在这里写下答案  -----------------------------------
				// 使用 map 和 concatAll 把 movieLists 打平成 video id 的数组。

				return movieLists.
				  map(function(movieList) {
					return movieList.videos.map(function(video) {
						return video.id;
					  });
				  }).
				  concatAll();

				// ------------  在这里写下答案  -----------------------------------
			}
		</pre>

		<p class="post"><b>干得漂亮！</b> 掌握 map() 和 concatAll() 的结合使用对于高效率的函数式编程而言十分重要。你已经迈出了坚实的一步！我们来尝试一个更加复杂的例子。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 12: 获取每个 video 的 id， title 和 150x200 大小的 box art url</h4>

		<p>你已经成功地展开过一个两层深的树了，我们来试一下三层的。对于每个 video，我们不是只有一个 boxart url，而是有一组 boxart 对象，每个对象里包含了不同的大小和 url。你需要做这样一个查询，从 movieLists 中把每个 video 的 {id, title, boxart} 筛选出来，而且这次结果中的 boxart url 需要来自具有 150x200px 尺寸的 boxart 对象。试着使用 map()，concatAll() 和 filter() 解决这个问题。</p>
		<a name="indexers"></a>

		<p><b>还有一件事：你<u>不能</u>使用数组下标。</b>也就是说这样的写法是
			<span style="color:red">非法的</span>:</p>
			<pre>
				var itemInArray = movieLists<span style="color:red">[0]</span>;
			</pre>

		<p>更进一步的，<b>在接下来的所有练习中你都不能使用下标</b>，除非你是在实现开始提到的那五个函数中的某一个。这样做是有很大的好处的，具体的好处我们会在后面解释清楚。现在你只需要遵守这个规定，并且相信这样做的目的是好的就可以了 :-)</p>

		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
						{
							name: "Instant Queue",
							videos : [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "New Releases",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];


				// 使用一个或者多个 map，concatAll，filter 方法拿到一个有下列元素的数组
				// [
				//	 {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				//	 {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
				//	 {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
				//	 {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists // 完成这个语句

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output">
		</div>

		<pre class="verifier">
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					got,
					expected = JSON.stringify([
						{"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
						{"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
						{"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
					].sortBy(function(v) { return v.id }));

				if (str.indexOf('[0]') !== -1) {
					throw "你不能使用数组下标。你可能过早地创建了对象。与其使用数组下标来从数组中获取 boxart，试着使用 map() 方法在投影函数中创建新的对象";
				}

				videos = videos.sortBy(function(v) { return v.id });
				got = JSON.stringify(videos);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "Instant Queue",
							videos : [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "New Releases",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];


				// 使用一个或者多个 map，concatAll，filter 方法拿到一个有下列元素的数组
				// [
				//     {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				//     {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
				//     {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
				//     {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists.
				  map(function(movieList) {
					return movieList.videos.
					  map(function(video) {
						return video.boxarts.
						  filter(function(boxart) {
							return boxart.width === 150;
						  }).
						  map(function(boxart) {
							return {id: video.id, title: video.title, boxart: boxart.url};
						  });
					  }).
					  concatAll();
				  }).
				  concatAll();

			}
		</pre>
		<p class="post">精彩！现在你已经学会了使用 concatAll()， map() 以及 filter() 进行树的查询。
			注意到<b>map() 和 concatAll() 经常会一起使用。</b>我们来加入一个小的助手函数来处理这种场景。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 13: 实现 concatMap()</h4>

		<p>几乎每次我们需要展开一个树的时候，都会链接使用 map() 和 concatAll()。有些时候，如果我们需要处理的树有好几层深，我们就需要在代码中重复好几次这种写法。为了让代码更简单，我们加入 concatMap 方法，它就是一个 map 操作, 然后紧接一个 concatAll。</p>
		<textarea class="code" rows="20" cols="80">
			Array.prototype.concatMap = function(projectionFunctionThatReturnsArray) {
				return this.
					map(function(item) {
						// ------------  在这里写下答案  -----------------------------------
						// 对每个元素都执行投影函数，这个函数会返回一个子数组，整个操作会产生一个二维数组
						// ------------  在这里写下答案  -----------------------------------
					}).
					// apply the concatAll function to flatten the two-dimensional array
					concatAll();
			};

			/*
				var spanishFrenchEnglishWords = [ ["cero","rien","zero"], ["uno","un","one"], ["dos","deux","two"] ];
				// collect all the words for each number, in every language, in a single, flat list
				var allWords = [0,1,2].
					concatMap(function(index) {
						return spanishFrenchEnglishWords[index];
					});

				return JSON.stringify(allWords) === '["cero","rien","zero","uno","un","one","dos","deux","two"]';
			*/
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Implement concatAll
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					spanishFrenchEnglishWords = [ ["cero","rien","zero"], ["uno","un","one"], ["dos","deux","two"] ],
					allWords = [0,1,2],
					result,
					expected = '["cero","rien","zero","uno","un","one","dos","deux","two"]';


				var allWords = [0,1,2].
					concatMap(function(index) {
						return spanishFrenchEnglishWords[index];
					});

				if (JSON.stringify(allWords) !== expected) {
					throw "Expected " + expected;
				}
			}
		</pre>
		<pre class="answer">
			Array.prototype.concatMap = function(projectionFunctionThatReturnsArray) {
				return this.
					map(function(item) {
						return projectionFunctionThatReturnsArray(item);
					}).
					// apply the concatAll function to flatten the two-dimensional array
					concatAll();
			};

			/*
				var spanishFrenchEnglishWords = [ ["cero","rien","zero"], ["uno","un","one"], ["dos","deux","two"] ];
				// collect all the words for each number, in every language, in a single, flat list
				var allWords = [0,1,2].
					concatMap(function(index) {
						return spanishFrenchEnglishWords[index];
					});

				return JSON.stringify(allWords) === '["cero","rien","zero","uno","un","one","dos","deux","two"]';
			*/
		</pre>


		<p class="post">从现在起，在展开树的时候不需要再使用 map().concatAll()，我们可以直接使用 concatMap 函数。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 14: 使用 concatMap() 去检索每一个视频的 id，title，和 boxarts url。</h4>

		<p>让我们再来做一下刚刚做过的那个练习。这一次我们将用 concatMap() 来替换 map().concatAll() 来简化代码。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
						{
							name: "Instant Queue",
							videos : [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "New Releases",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];


				// 使用一个或者多个 concatMap, map，filter 方法拿到一个有下列元素的数组
				// [
				//	 {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				//	 {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
				//	 {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
				//	 {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists // Complete this expression!

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>

		<pre class="verifier">
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					got,
					expected = JSON.stringify([
						{"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
						{"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
						{"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
					].sortBy(function(v) { return v.id }));

				videos = videos.sortBy(function(v) { return v.id });
				got = JSON.stringify(videos);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "Instant Queue",
							videos : [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						},
						{
							name: "New Releases",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"bookmark": []
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"bookmark": [{ id:432534, time:65876586 }]
								}
							]
						}
					];


				// 使用一个或者多个 concatMap, map，filter 方法拿到一个有下列元素的数组
				// [
				//     {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				//     {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber150.jpg" },
				//     {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys150.jpg" },
				//     {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists.concatMap(function(movieList) {
					return movieList.videos.concatMap(function(video) {
						return video.boxarts.
							filter(function(boxart) {
								return boxart.width === 150;
						  	}).
						  	map(function(boxart) {
								return {id: video.id, title: video.title, boxart: boxart.url};
							});
					  });
				  });
			}
		</pre>
		<p class="post">将最后一个运算变为 map，是一种访问若干嵌套的 concatMap 运算的很常见的方式。你可以把这种方式当做一个嵌套的 forEach 的函数式版本。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>缩减数组</h3>
		<p>有时我们需要<i>同时</i>对数组中很多项进行操作。举例，我们需要找到数组中的最大整型值。我们不能使用 filter()，因为 filter() 每次只对一项进行检查。为了找到这个最大整型值，我们需要互相比较数组中的每一项。
		</p>
		<p>先<i>假设</i>某一项是最大值（可能是第一项)，然后再把它和数组中其余所有项进行对比。每一次我们找到一个比假想值大的数时，就把这个假想值替换为我们找到的这个值，直到我们遍历完整个数组。</p>
		<p>如果我们用闭包来替换特定大小的比较，我们需要写一个函数来遍历数组。每一步我们的函数将在当前的值和最后的值运用闭包 ，下一次就将结果作为最后的值。最后我们只剩下一个值。这个过程被称为<i>缩减</i>，因为我们将很多的值变为了一个值。</p>

		<h4>练习 15: 使用 forEach 找到最大的 box art</h4>

		<p>在这个例子中我们将使用 forEach 找到最大的 box art。我们每次检查一个新的 boxart 都会更新一下目前找到的最大值 maximumSize。
			如果当前 boxart 的 size 小于这个值，就丢弃它，如果大于，就保留它。最后我们会得到一个拥有最大尺寸的 boxart。</p>
		<textarea class="code" rows="15" cols="80">
			function() {
				var boxarts = [
						{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
					],
					currentSize,
					maxSize = -1,
					largestBoxart;

				boxarts.forEach(function(boxart) {
					currentSize = boxart.width * boxart.height;
					if (currentSize > maxSize) {
						largestBoxart = boxart;
						maxSize = currentSize;
					}
				});

				return largestBoxart;
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Find largest box art
			function(str){
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					boxart = fun(),
					got = JSON.stringify(boxart),
					expected = JSON.stringify({ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" });

				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var boxarts = [
						{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
					],
					currentSize,
					maxSize = -1,
					largestBoxart;

				boxarts.forEach(function(boxart) {
					currentSize = boxart.width * boxart.height;
					if (currentSize > maxSize) {
						largestBoxart = boxart;
						maxSize = currentSize;
					}
				});

				return largestBoxart;
			}
		</pre>
		<p class="post">这个过程叫做缩减（reduction）。我们每次使用上次计算的结果，来计算当前的值。在这个例子中我们
			还是需要手动进行遍历操作。如果我们只需要声明我们想要做的操作，不就更好了吗？下面我们就来写这样一个助手函数用来对数组进行缩减操作。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 16: 实现 reduce()</h4>

		<p>和 map 类似，我们给 Array 类型增加一个 reduce 方法。</p>
		<textarea class="code" rows="40" cols="80">
			// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }); === [6];
			// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }, 10); === [16];

			Array.prototype.reduce = function(combiner, initialValue) {
				var counter,
					accumulatedValue;

				// 如果数组是空，直接返回
				if (this.length === 0) {
					return this;
				}
				else {
					// 如果用户没有提供初始值，使用数组当中的第一个元素。
					if (arguments.length === 1) {
						counter = 1;
						accumulatedValue = this[0];
					}
					else if (arguments.length >= 2) {
						counter = 0;
						accumulatedValue = initialValue;
					}
					else {
						throw "Invalid arguments.";
					}

					// 遍历整个数组，把当前元素和上一次计算的结果，传给 combiner 函数，直到遍历完整个
					// 数组，只剩下一个值。
					while(counter < this.length) {
						accumulatedValue = combiner(accumulatedValue, this[counter])
						counter++;
					}

					return [accumulatedValue];
				}
			};
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Implement reduce
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					numbers = [1,2,3],
					sum = numbers.reduce(function(acc,curr) { return acc + curr }),
					expected = JSON.stringify([6]),
					sum2 = numbers.reduce(function(acc,curr) { return acc + curr },10),
					expected2 = JSON.stringify([16]);

				if (JSON.stringify(sum) !== expected) {
					throw "Expected that [1,2,3].reduce(function(accumulated,current) { return accumulated + current; }) === [6]. Instead got " + JSON.stringify(sum);
				}
				if (JSON.stringify(sum2) !== expected2) {
					throw "Expected that [1,2,3].reduce(function(accumulated,current) { return accumulated + current; }, 10) === [16]. Instead got " + JSON.stringify(sum2);
				}
			}
		</pre>
		<pre class="answer">
			// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }); === [6];
			// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }, 10); === [16];

			Array.prototype.reduce = function(combiner, initialValue) {
				var counter,
					accumulatedValue;

				// 如果数组是空，直接返回
				if (this.length === 0) {
					return this;
				}
				else {
					// 如果用户没有提供初始值，使用数组当中的第一个元素。
					if (arguments.length === 1) {
						counter = 1;
						accumulatedValue = this[0];
					}
					else if (arguments.length >= 2) {
						counter = 0;
						accumulatedValue = initialValue;
					}
					else {
						throw "Invalid arguments.";
					}

					// 遍历整个数组，把当前元素和上一次计算的结果，传给 combiner 函数，直到遍历完整个
					// 数组，只剩下一个值。
					while(counter < this.length) {
						accumulatedValue = combiner(accumulatedValue, this[counter])
						counter++;
					}

					return [accumulatedValue];
					}
			};
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson"><h4>练习 17: 获取最大的 rating。</h4>

		<p>下面我们使用 reduce 方法找到一个 rating 数组当中的最大值。</p>
		<textarea class="code" rows="15" cols="80">
			function() {
				var ratings = [2,3,1,4,5];

				// 返回一个只有最大 rating 的数组。注意 reduce 总是返回一个只包含一个元素的数组。
				return ratings.
				reduce   // Complete this expression
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			 // Find largest rating
			function(str){
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					boxarts = fun(),
					got = JSON.stringify(boxarts),
					expected = JSON.stringify([5]);


				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var ratings = [2,3,1,4,5];

				// 返回一个只包含最大 rating 的数组。注意 reduce 总是返回一个只包含一个元素的数组。
				return ratings.
				  reduce(function(acc, curr) {
					if(acc > curr) {
					  return acc;
					}
					else {
					  return curr;
					}
				  });
			}
		</pre>
		<p class="post">干得漂亮。下面我们将试着把 reduce() 和其他函数结合起来构建更复杂的查询操作。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 18: 获取最大的 boxart 的 url</h4>

		<p>我们试一下结合使用 reduce() 和 map()，将多个 boxart 对象缩减成一个值：最大 boxart 的 url。</p>
		<textarea class="code" rows="15" cols="80">
			function() {
				var boxarts = [
						{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
					];

				// 返回一个只包含最大 boxart 的 URL 的数组。注意 reduce 总是返回一个只包含一个元素的数组。
				return boxarts.
					reduce   // Complete this expression
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Find largest box art with reduce
			function(str){
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					boxarts = fun(),
					got = JSON.stringify(boxarts),
					expected = JSON.stringify(["http://cdn-0.nflximg.com/images/2891/Fracture425.jpg"]);


				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var boxarts = [
						{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
						{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ width: 425, height:150, url:"http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
					];

				// 返回一个只包含最大 boxart 的 URL 的数组。注意 reduce 总是返回一个只包含一个元素的数组。
				return boxarts.
				  reduce(function(acc,curr) {
					if (acc.width * acc.height > curr.width * curr.height) {
					  return acc;
					}
					else {
					  return curr;
					}
				  }).
				  map(function(boxart) {
					return boxart.url;
				  });
			}
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 19: 带有初始值的缩减 </h4>

		<p>有时候，我们想缩减一个数组，同时希望缩减后的值类型，不同于数组当中的元素值类型。
			举个例子，我们有一个 video 的数组，我们想通过缩减它来得到一个键是 video id，值是 video title 的 map。</p>

		<textarea id="q18" class="code" rows="15" cols="80">
			function() {
				var videos = [
					{
						"id": 65432445,
						"title": "The Chamber"
					},
					{
						"id": 675465,
						"title": "Fracture"
					},
					{
						"id": 70111470,
						"title": "Die Hard"
					},
					{
						"id": 654356453,
						"title": "Bad Boys"
					}
				];

				// Expecting this output...
				// [
				//	 {
				//		 "65432445": "The Chamber",
				//		 "675465": "Fracture",
				//		 "70111470": "Die Hard",
				//		 "654356453": "Bad Boys"
				//	 }
				// ]
				return videos.
					reduce(function(accumulatedMap, video) {

						// Object.create() makes a fast copy of the accumulatedMap by
						// creating a new object and setting the accumulatedMap to be the
						// new object's prototype.
						// Initially the new object is empty and has no members of its own,
						// except a pointer to the object on which it was based. If an
						// attempt to find a member on the new object fails, the new object
						// silently attempts to find the member on its prototype. This
						// process continues recursively, with each object checking its
						// prototype until the member is found or we reach the first object
						// we created.
						// If we set a member value on the new object, it is stored
						// directly on that object, leaving the prototype unchanged.
						// Object.create() is perfect for functional programming because it
						// makes creating a new object with a different member value almost
						// as cheap as changing the member on the original object!

						var copyOfAccumulatedMap = Object.create(accumulatedMap);

						// ----- 用 video id 做 key 把 video title 插入新的 map 中

						return copyOfAccumulatedMap;
					},
					// Use an empty map as the initial value instead of the first item in
					// the list.
					{});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Reducing with an initial value
			function(str){
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videoMap = fun()[0],
					expected = [
						{
							"65432445": "The Chamber",
							"675465": "Fracture",
							"70111470": "Die Hard",
							"654356453": "Bad Boys"
						}
					];

				if (!(videoMap["65432445"] === "The Chamber" && videoMap["675465"] === "Fracture" && videoMap["70111470"] === "Die Hard" && videoMap["654356453"] === "Bad Boys")) {
					throw "Expected " + JSON.stringify(expected);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var videos = [
					{
						"id": 65432445,
						"title": "The Chamber"
					},
					{
						"id": 675465,
						"title": "Fracture"
					},
					{
						"id": 70111470,
						"title": "Die Hard"
					},
					{
						"id": 654356453,
						"title": "Bad Boys"
					}
				];

				// Expecting this output...
				// [
				//     {
				//         "65432445": "The Chamber",
				//         "675465": "Fracture",
				//         "70111470": "Die Hard",
				//         "654356453": "Bad Boys"
				//     }
				// ]
				return videos.
					reduce(function(accumulatedMap, video) {

						// Object.create() makes a fast copy of the accumulatedMap by
						// creating a new object and setting the accumulatedMap to be the
						// new object's prototype.
						// Initially the new object is empty and has no members of its own,
						// except a pointer to the object on which it was based. If an
						// attempt to find a member on the new object fails, the new object
						// silently attempts to find the member on its prototype. This
						// process continues recursively, with each object checking its
						// prototype until the member is found or we reach the first object
						// we created.
						// If we set a member value on the new object, it is stored
						// directly on that object, leaving the prototype unchanged.
						// Object.create() is perfect for functional programming because it
						// makes creating a new object with a different member value almost
						// as cheap as changing the member on the original object!

						var copyOfAccumulatedMap = Object.create(accumulatedMap);

						copyOfAccumulatedMap[video.id] = video.title;

						return copyOfAccumulatedMap;
					},
					// Use an empty map as the initial value instead of the first item in
					// the list.
					{});
			}
		</pre>

		<p class="post">做的好。现在我们试着把 reduce 和其他函数结合起来构建更复杂的查询操作。</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 20: 取出每个 vidode 的 id，title 以及<i>最小的</i> boxart 的 url。</h4>

		<p>这个练习是我们之前解决过的问题的一个变体。在之前的问题中，我们取出了 width 为 150px 的 boxart 的 url。
			这次我们使用 reduce() 替代 filter，取出<i>最小的</i> box art。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
					{
						name: "New Releases",
						videos: [
							{
								"id": 70111470,
								"title": "Die Hard",
								"boxarts": [
									{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 654356453,
								"title": "Bad Boys",
								"boxarts": [
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
									{ width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }

								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					},
					{
						name: "Thrillers",
						videos: [
							{
								"id": 65432445,
								"title": "The Chamber",
								"boxarts": [
									{ width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 675465,
								"title": "Fracture",
								"boxarts": [
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
									{ width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
									{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					}
				];


				// 使用一个或多个 concatMap， map，和 reduce 操作得到下面的数组（顺序无关）。
				// [
				//	 {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
				//	 {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
				//	 {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" },
				//	 {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists.
					concatMap(function(movieList) {

					})

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output">
		</div>
		<pre class="verifier">
			// Find the id, title, and smallest box art.
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					got,
					expected = JSON.stringify([
						{"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
						{"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
						{"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" },
						{"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
					].sortBy(function(v) { return v.id }));

				if (str.indexOf('[0]') !== -1){
					throw "You're not allowed to index into the array. You might be creating the object too early. Instead of using an indexer to get the boxart out of the array, try adding a call to map() and creating the object inside the projection function.";
				}
				videos = videos.sortBy(function(v) { return v.id });
				got = JSON.stringify(videos);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
					{
						name: "New Releases",
						videos: [
							{
								"id": 70111470,
								"title": "Die Hard",
								"boxarts": [
									{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 654356453,
								"title": "Bad Boys",
								"boxarts": [
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
									{ width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }

								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					},
					{
						name: "Thrillers",
						videos: [
							{
								"id": 65432445,
								"title": "The Chamber",
								"boxarts": [
									{ width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 4.0,
								"bookmark": []
							},
							{
								"id": 675465,
								"title": "Fracture",
								"boxarts": [
									{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
									{ width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
									{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
								],
								"url": "http://api.netflix.com/catalog/titles/movies/70111470",
								"rating": 5.0,
								"bookmark": [{ id:432534, time:65876586 }]
							}
						]
					}
				];


				// 使用一个或多个 concatMap， map，和 reduce 操作得到下面的数组（顺序无关）。
				// [
				//     {"id": 675465,"title": "Fracture","boxart":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
				//     {"id": 65432445,"title": "The Chamber","boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
				//     {"id": 654356453,"title": "Bad Boys","boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" },
				//     {"id": 70111470,"title": "Die Hard","boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" }
				// ];

				return movieLists.concatMap(function(movieList) {
				  return movieList.videos.concatMap(function(video) {
				    return video.boxarts.
					  reduce(function(acc,curr) {
						if (acc.width * acc.height < curr.width * curr.height) {
						  return acc;
						}
						else {
						  return curr;
						}
					  }).
					  map(function(boxart) {
						return {id: video.id, title: video.title, boxart: boxart.url};
					  });
				  });
				});

			}
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>合并数组</h3>
		<p>有时候我们需要把两个数组合并(zip)，分别从两个数组当中拿出一个元素，组成一个元素对的数组。把数组想象成拉链，每个数组是拉链的一边，
			元素是拉链的牙，这样你可以更好地理解合并数组是什么样的操作。</p>
		<h4>练习 21: 按数组下标顺序合并 videos 和 bookmarks</h4>

		<p>使用一个 for 循环，同时遍历 videos 和 bookmarks 数组。对每一个 video 和 bookmark 创建一个 {videoId, bookmarkId} 对，
			并把它加入 videoIdAndBookmarkIdPairs 数组中。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var videos = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						}
					],
					bookmarks = [
						{id: 470, time: 23432},
						{id: 453, time: 234324},
						{id: 445, time: 987834}
					],
				counter,
				videoIdAndBookmarkIdPairs = [];

				for(var counter = 0; counter < Math.min(videos.length, bookmarks.length); counter++) {
					// 创建一个 {videoId, bookmarkId} 对并把它添加到 videoIdAndBookmarkIdPairs。
				}

				return videoIdAndBookmarkIdPairs;
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Zip imperatively
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					pairs = fun(),
					got,
					expected = '[{"videoId":65432445,"bookmarkId":445},{"videoId":70111470,"bookmarkId":470},{"videoId":654356453,"bookmarkId":453}]';

				pairs = pairs.sortBy(function(v) { return v.videoId });
				got = JSON.stringify(pairs);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var videos = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						}
					],
					bookmarks = [
						{id: 470, time: 23432},
						{id: 453, time: 234324},
						{id: 445, time: 987834}
					],
				counter,
				videoIdAndBookmarkIdPairs = [];

				for(var counter = 0; counter < Math.min(videos.length, bookmarks.length); counter++) {
				  videoIdAndBookmarkIdPairs.push({videoId: videos[counter].id, bookmarkId: bookmarks[counter].id});
				}

				return videoIdAndBookmarkIdPairs;
			}
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 22: 实现 zip</h4>

		<p>我们来给 Array 类型添加一个静态的 zip() 方法。zip 方法接受一个 combiner 函数作为参数，同时遍历两个数组，并且在两边数组的对应元素执行
			combiner 函数。zip 方法需要元素才能调用 combiner，因此 zip 返回的数组长度是两个数组当中最小的那个的长度。
		<p>
		<textarea class="code" rows="40" cols="80">
			// JSON.stringify(Array.zip([1,2,3],[4,5,6], function(left, right) { return left + right })) === '[5,7,9]'

			Array.zip = function(left, right, combinerFunction) {
				var counter,
					results = [];

				for(counter = 0; counter < Math.min(left.length, right.length); counter++) {
					// 对两个数组中的对应元素执行 combinerFunction 方法。
				}

				return results;
			};
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Implement zip
			function(str) {
				preVerifierHook();
				var fun = eval(str),
					left = [1,2,3],
					right = [4,5,6],
					sum = Array.zip(left, right, function(left, right){ return left + right; }),
					expected = '[5,7,9]';

				if (JSON.stringify(sum) !== expected) {
					showLessonErrorMessage(expected, JSON.stringify(sum));
				}
			}
		</pre>
		<pre class="answer">
			// JSON.stringify(Array.zip([1,2,3],[4,5,6], function(left, right) { return left + right })) === '[5,7,9]'

			Array.zip = function(left, right, combinerFunction) {
				var counter,
					results = [];

				for(counter = 0; counter < Math.min(left.length, right.length); counter++) {
					results.push(combinerFunction(left[counter],right[counter]));
				}

				return results;
			};
        </pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 23: 按数组下标顺序合并 videos 和 bookmarks</h4>

		<p>我们来重复练习 21 的内容，不过这次使用新的 zip() 方法。对每一个 video 和 bookmark 创建一个 {videoId, bookmarkId} 对。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var videos = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						}
					],
					bookmarks = [
						{id: 470, time: 23432},
						{id: 453, time: 234324},
						{id: 445, time: 987834}
					];

				return Array.
					zip( //... finish this expression
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
		<pre class="verifier">
			// Combine videos and bookmarks
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					pairs = fun(),
					got,
					expected = '[{"videoId":65432445,"bookmarkId":445},{"videoId":70111470,"bookmarkId":470},{"videoId":654356453,"bookmarkId":453}]';

				pairs = pairs.sortBy(function(v) { return v.videoId });
				got = JSON.stringify(pairs);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var videos = [
						{
							"id": 70111470,
							"title": "Die Hard",
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						},
						{
							"id": 65432445,
							"title": "The Chamber",
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 4.0,
						},
						{
							"id": 675465,
							"title": "Fracture",
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
							"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
							"rating": 5.0,
						}
					],
					bookmarks = [
						{id: 470, time: 23432},
						{id: 453, time: 234324},
						{id: 445, time: 987834}
					];

				return Array.
					zip(
					  videos,
					  bookmarks,
					  function(video, bookmark) {
						return {videoId: video.id, bookmarkId: bookmark.id};
					  });
			}
        </pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 24: 取出每个 video 的 id，title，middle 类型的 interesting moment time, 和 <i>最小的</i> box art url.</h4>

		<p>这是我们之前解决过问题的一个变种。这次我们的每个 video 包含了一个关键时刻的集合，关键时刻代表这个时间的画面是视频当中具有代表性的或者最有趣的。
			注意 boxart 和 interestingMoments 数组处于树的同一深度。使用 zip() <i>同时</i> 取出 middle 类型的 interesting moment 的 time 和
			最小的 boxart 的 url。对每一个 video，返回一个 {id, title, time, url } 对象。</p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"interestingMoments": [
										{ type: "End", time:213432 },
										{ type: "Start", time: 64534 },
										{ type: "Middle", time: 323133}
									]
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"interestingMoments": [
										{ type: "End", time:54654754 },
										{ type: "Start", time: 43524243 },
										{ type: "Middle", time: 6575665}
									]
								}
							]
						},
						{
							name: "Instant Queue",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"interestingMoments": [
										{ type: "End", time:132423 },
										{ type: "Start", time: 54637425 },
										{ type: "Middle", time: 3452343}
									]
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"interestingMoments": [
										{ type: "End", time:45632456 },
										{ type: "Start", time: 234534 },
										{ type: "Middle", time: 3453434}
									]
								}
							]
						}
					];

				//------------ 完成这个表达式 --------------
				return movieLists.
					concatMap(function(movieList) {

					});

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<pre class="verifier">
			// Find id, title, smallest box art, and bookmark id
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					videos = fun(),
					got,
					expected = '[{"id":675465,"title":"Fracture","time":3453434,"url":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg"},{"id":65432445,"title":"The Chamber","time":3452343,"url":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg"},{"id":70111470,"title":"Die Hard","time":323133,"url":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg"},{"id":654356453,"title":"Bad Boys","time":6575665,"url":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg"}]';

				videos = videos.sortBy(function(v) { return v.id });
				got = JSON.stringify(videos);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var movieLists = [
						{
							name: "New Releases",
							videos: [
								{
									"id": 70111470,
									"title": "Die Hard",
									"boxarts": [
										{ width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"interestingMoments": [
										{ type: "End", time:213432 },
										{ type: "Start", time: 64534 },
										{ type: "Middle", time: 323133}
									]
								},
								{
									"id": 654356453,
									"title": "Bad Boys",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
										{ width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }

									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"interestingMoments": [
										{ type: "End", time:54654754 },
										{ type: "Start", time: 43524243 },
										{ type: "Middle", time: 6575665}
									]
								}
							]
						},
						{
							name: "Instant Queue",
							videos: [
								{
									"id": 65432445,
									"title": "The Chamber",
									"boxarts": [
										{ width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 4.0,
									"interestingMoments": [
										{ type: "End", time:132423 },
										{ type: "Start", time: 54637425 },
										{ type: "Middle", time: 3452343}
									]
								},
								{
									"id": 675465,
									"title": "Fracture",
									"boxarts": [
										{ width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
										{ width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
										{ width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" }
									],
									"url": "http://api.netflix.com/catalog/titles/movies/70111470",
									"rating": 5.0,
									"interestingMoments": [
										{ type: "End", time:45632456 },
										{ type: "Start", time: 234534 },
										{ type: "Middle", time: 3453434}
									]
								}
							]
						}
					];

					//------------ 完成这个表达式 --------------
					return movieLists.concatMap(function(movieList) {
					return movieList.videos.concatMap(function(video) {
						return Array.zip(
							video.boxarts.reduce(function(acc,curr) {
								if (acc.width * acc.height < curr.width * curr.height) {
							  	  	return acc;
								}
								else {
							  		return curr;
								}
						  	}),
							video.interestingMoments.filter(function(interestingMoment) {
								return interestingMoment.type === "Middle";
							}),
						  	function(boxart, interestingMoment) {
								return {id: video.id, title: video.title, time: interestingMoment.time, url: boxart.url};
						  	});
					});
				});
			}
		</pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h3>强大的查询能力</h3>

		<p>现在我们已经学习了 5 个操作符。让我们通过实战练习一下如何书写复杂查询。</p>

		<h4>练习 25: 把数组转换成树</h4>

		<p>当信息使用像 JSON 一样的树状结构存储时，数据之间的关系是从父亲节点指向孩子节点。在数据库这样的关系型系统里面，数据之前的关系是由孩子节点指向
			父亲节点。两种组织信息的方式在表达能力上是一致。根据使用场景不同，我们可能会希望数据采用特定的方式进行组织。
			这可能会吓你一跳，不过通过之前学的 5 个函数，你已经能够很容易地将数据在这两种组织方式之间转换了。换句话说
			<b>你不仅仅能够从树中查询出数组，你也可以从数组当中查询出树</b>。</p>

		<p>现在我们有两个数组，分别包含 list 和 video 信息。每个 video 有一个 listId 字段，记录着它的父亲 list。我们想得到一个 list 对象的数组，
			其中的对象包含一个 name 和一个 video 的数组。这个 video 数组会包含 video 的 id 和 title。也就是说，我们想要构造出下面的结构：</p>
        <pre>
			[
				{
					"name": "New Releases",
					"videos": [
						{
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"id": 675465,
							"title": "Fracture"
						}
					]
				},
				{
					"name": "Thrillers",
					"videos": [
						{
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"id": 654356453,
							"title": "Bad Boys"
						}
					]
				}
			]
        </pre>
		<p><b>注意：在创建对象时，确保对象（list 和 video）是按照上面的顺序添加的。这一点不影响你代码的正确性，但是检查答案时期望的顺序就是上面的顺序。</b></p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var lists = [
						{
							"id": 5434364,
							"name": "New Releases"
						},
						{
							"id": 65456475,
							"name": "Thrillers"
						}
					],
					videos = [
						{
							"listId": 5434364,
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"listId": 5434364,
							"id": 675465,
							"title": "Fracture"
						},
						{
							"listId": 65456475,
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"listId": 65456475,
							"id": 654356453,
							"title": "Bad Boys"
						}
					];

				return lists. // complete this expression
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output"></div>
        <pre class="verifier">
			// Combine videos and bookmarks
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					pairs = fun(),
					got,
					expected = '[{"name":"New Releases","videos":[{"id":65432445,"title":"The Chamber"},{"id":675465,"title":"Fracture"}]},{"name":"Thrillers","videos":[{"id":70111470,"title":"Die Hard"},{"id":654356453,"title":"Bad Boys"}]}]';

				got = JSON.stringify(pairs);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
		<pre class="answer">
			function() {
				var lists = [
						{
							"id": 5434364,
							"name": "New Releases"
						},
						{
							"id": 65456475,
							name: "Thrillers"
						}
					],
					videos = [
						{
							"listId": 5434364,
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"listId": 5434364,
							"id": 675465,
							"title": "Fracture"
						},
						{
							"listId": 65456475,
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"listId": 65456475,
							"id": 654356453,
							"title": "Bad Boys"
						}
					];

				return lists.map(function(list) {
					return {
						name: list.name,
						videos:
							videos.
								filter(function(video) {
									return video.listId === list.id;
								}).
								map(function(video) {
									return {id: video.id, title: video.title};
								})
					};
				});
			}
        </pre>
		<p class="post">看样子你已经学会了如何使用 map 和 filter 来通过 key <i>关联</i> 两个不同的数组。让我们来看一个更加复杂的例子...</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 26: 把数组转换成 <i>更深层的</i> 树</h4>

		<p>我们试着创建一个更深层的树形结构。这次我们有 4 个不同的数组，分别包含 list，video ，boxarts 和 bookmarks。
			每个对象都包含一个 parent 的 id，标明自己的父亲节点。我们想要构造一个 list 对象的数组，其中每个对象包含 name 和
			video 的数组。这个 video 数组包含 video 的 id，title，bookmark 的 time，和最小的 boxart url。也就是我们想要构造
		    下面的结构：</p>
        <pre>
			[
				{
					"name": "New Releases",
					"videos": [
						{
							"id": 65432445,
							"title": "The Chamber",
							"time": 32432,
							"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg"
						},
						{
							"id": 675465,
							"title": "Fracture",
							"time": 3534543,
							"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture120.jpg"
						}
					]
				},
				{
					"name": "Thrillers",
					"videos": [
						{
							"id": 70111470,
							"title": "Die Hard",
							"time": 645243,
							"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard150.jpg"
						},
						{
							"id": 654356453,
							"title": "Bad Boys",
							"time": 984934,
							"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg"
						}
					]
				}
			]
        </pre>

		<p><b>注意：在创建对象时，确保对象（list 和 video）是按照上面的顺序添加的。这一点不影响你代码的正确性，但是检查答案时期望的顺序就是上面的顺序。</b></p>
		<textarea class="code" rows="60" cols="80">
			function() {
				var lists = [
						{
							"id": 5434364,
							"name": "New Releases"
						},
						{
							"id": 65456475,
							name: "Thrillers"
						}
					],
					videos = [
						{
							"listId": 5434364,
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"listId": 5434364,
							"id": 675465,
							"title": "Fracture"
						},
						{
							"listId": 65456475,
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"listId": 65456475,
							"id": 654356453,
							"title": "Bad Boys"
						}
					],
					boxarts = [
						{ videoId: 65432445, width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
						{ videoId: 65432445, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" },
						{ videoId: 675465, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ videoId: 675465, width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
						{ videoId: 675465, width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ videoId: 70111470, width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
						{ videoId: 70111470, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" },
						{ videoId: 654356453, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
						{ videoId: 654356453, width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }
					],
					bookmarks = [
						{ videoId: 65432445, time: 32432 },
						{ videoId: 675465, time: 3534543 },
						{ videoId: 70111470, time: 645243 },
						{ videoId: 654356453, time: 984934 }
					];

				return lists. // complete this expression

			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output">
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks
			function(str) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					pairs = fun(),
					got,
					expected = '[{"name":"New Releases","videos":[{"id":65432445,"title":"The Chamber","time":32432,"boxart":"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg"},{"id":675465,"title":"Fracture","time":3534543,"boxart":"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg"}]},{"name":"Thrillers","videos":[{"id":70111470,"title":"Die Hard","time":645243,"boxart":"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg"},{"id":654356453,"title":"Bad Boys","time":984934,"boxart":"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg"}]}]';

				got = JSON.stringify(pairs);
				if (got !== expected) {
					showLessonErrorMessage(expected, got);
				}
			}
		</pre>
        <pre class="answer">
			function() {
				var lists = [
						{
							"id": 5434364,
							"name": "New Releases"
						},
						{
							"id": 65456475,
							name: "Thrillers"
						}
					],
					videos = [
						{
							"listId": 5434364,
							"id": 65432445,
							"title": "The Chamber"
						},
						{
							"listId": 5434364,
							"id": 675465,
							"title": "Fracture"
						},
						{
							"listId": 65456475,
							"id": 70111470,
							"title": "Die Hard"
						},
						{
							"listId": 65456475,
							"id": 654356453,
							"title": "Bad Boys"
						}
					],
					boxarts = [
						{ videoId: 65432445, width: 130, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber130.jpg" },
						{ videoId: 65432445, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/TheChamber200.jpg" },
						{ videoId: 675465, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
						{ videoId: 675465, width: 120, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture120.jpg" },
						{ videoId: 675465, width: 300, height:200, url:"http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
						{ videoId: 70111470, width: 150, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard150.jpg" },
						{ videoId: 70111470, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/DieHard200.jpg" },
						{ videoId: 654356453, width: 200, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys200.jpg" },
						{ videoId: 654356453, width: 140, height:200, url:"http://cdn-0.nflximg.com/images/2891/BadBoys140.jpg" }
					],
					bookmarks = [
						{ videoId: 65432445, time: 32432 },
						{ videoId: 675465, time: 3534543 },
						{ videoId: 70111470, time: 645243 },
						{ videoId: 654356453, time: 984934 }
					];

				return lists.map(function(list) {
					return {
						name: list.name,
						videos:
							videos.
								filter(function(video) {
									return video.listId === list.id;
								}).
								concatMap(function(video) {
									return Array.zip(
										bookmarks.filter(function(bookmark) {
											return bookmark.videoId === video.id;
										}),
										boxarts.filter(function(boxart) {
											return boxart.videoId === video.id;
										}).
										reduce(function(acc,curr) {
											return acc.width * acc.height < curr.width * curr.height ? acc : curr;
										}),
										function(bookmark, boxart) {
											return { id: video.id, title: video.title, time: bookmark.time, boxart: boxart.url };
										});
							})
					};
				});

			}
        </pre>
		<p class="post">哇！这是个很长的查询，但是代码相对于它做的事情来说，并不算很长。如果我们使用传统的循环操作，代码的可读性
			会大大下降。循环不能告诉读者所进行的操作是什么。当你看到一个循环的时候，你需要仔细阅读循环体中的代码，才能知道它是在
			做什么。它是在投影？还是在过滤？还是在缩减？通过例子的展示，相信你已经发现，当我们能够通过前面学的 5 个函数拿到几乎所有
			想要的结果时，为什么还要使用循环来查询数据呢？</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 27: 股票报价机</h4>

		<p>我们来看一个简单一些的问题。现在我们有一些 NASDAQ 股票不同时间的价格数据。每当股票价格变化时，NASDAQ 股票报价机就
			会在集合中加入一条数据。例如，我们在 10 天前买入了微软的股票，现在你想知道从那时候起，所有 MSFT 股票的价格情况。
			过滤集合，找到从 10 天前算起，所有 MSFT 的数据，然后使用 print() 函数打印出每个价格记录（包括时间戳）。
			 <b>注意：这不是一个有陷阱的题目，它就是像看起来那么简单。</b>
		</p>
		<pre>
			// The pricesNASDAQ collection looks something like this...
			var pricesNASDAQ = [
				// ... from the NASDAQ's opening day
				{name: "ANGI", price: 31.22, timeStamp: new Date(2011,11,15) },
				{name: "MSFT", price: 32.32, timeStamp: new Date(2011,11,15) },
				{name: "GOOG", price: 150.43, timeStamp: new Date(2011,11,15)},
				{name: "ANGI", price: 28.44, timeStamp: new Date(2011,11,16)},
				{name: "GOOG", price: 199.33, timeStamp: new Date(2011,11,16)},
				// ...and up to the present.
			];
		</pre>
		<textarea class="code" rows="60" cols="80">
			function(pricesNASDAQ, printRecord) {
				var microsoftPrices,
					now = new Date(),
					tenDaysAgo = new Date( now.getFullYear(), now.getMonth(), now.getDate() - 10);

				// use filter() to filter the trades for MSFT prices recorded any time after 10 days ago
				microsoftPrices =
					pricesNASDAQ.
						filter(function(priceRecord) {	 // finish this expression

				// Print the trades to the output console
				microsoftPrices.
					forEach(function(priceRecord) {
						printRecord(priceRecord);
					});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<p>命令行输出</p>

		<div class="output" style="height:200px;overflow:scroll">
		</div>
        <pre class="verifier">
			// Combine videos and bookmarks
			function(str, lesson) {
				preVerifierHook();
				var output = $(".output", lesson)[0],
					fun = eval("(" + str + ")"),
					stockSymbols = ["MSFT", "GOOG","NFLX","OSTK"],
					input = [{name: "MSFT", price: 32.32, timeStamp: new Date() }, {name: "GOOG", price: 150.43, timeStamp: new Date(2011,11,15)}],
					expected = [input[0]],
					items = [],
					counter = 0;
					confirmPrint = function(item) {
						items.push(item);
					},
					print = function(item) {
						output.innerHTML += "MSFT " + item.price + " at " + item.timeStamp.toString() + "<" + "br" + ">";
						output.scrollTop = output.scrollHeight;
						counter++;
						if (counter % 100 === 0) {
							output.innerHTML = "";
						}
					},
					stocks =
						Rx.Observable.
							interval(250).
							map(function() {
								var symbol = stockSymbols[Math.floor(Math.random() * stockSymbols.length)];
								return {name: symbol, price: 30 + ((Math.floor(Math.random() * 100))/200), timeStamp: new Date()};
							});

				fun(input, confirmPrint);

				if (JSON.stringify(items) !== JSON.stringify(expected)) {
					throw "Got " + JSON.stringify(items, null, 4) + ", expected " + JSON.stringify(expected, null, 4);
				}

				fun(stocks, print);
			}
		</pre>
        <pre class="answer">
			function(pricesNASDAQ, printRecord) {
				var microsoftPrices,
					now = new Date(),
					tenDaysAgo = new Date( now.getFullYear(), now.getMonth(), now.getDate() - 10);

				// use filter() to filter the trades for MSFT prices recorded any time after 10 days ago
				microsoftPrices =
					pricesNASDAQ.
						filter(function(priceRecord) {
						  return priceRecord.name === 'MSFT' && priceRecord.timeStamp > tenDaysAgo;
						});

				// Print the trades to the output console
				microsoftPrices.
					forEach(function(priceRecord) {
						printRecord(priceRecord);
					});
			}
        </pre>
		<div class="post">
			<p><b>注意命令行输出在随着时间变化。</b> 现在看一下股票价格的时间戳，我们展示的股票价格，是在我们运行程序
				<i>之后</i> 才拿到的！我们的数组怎么能够包括来自未来的股票数据呢？ 难道我们一不小心破坏了
				空间时序统一性？</p>

			<p>这个谜题的答案在于，<b>pricesNASDAQ <u>不是</u> 一个数组</b>。数组只能够存储股票价格的一个快照，而这种新类型
				可以对于变化进行响应，随着时间更新自己。</p>

			<p>在下一节内容当中，我会向你展示这个神奇类型的内部原理。你将学习到如何将它用于建模，从鼠标事件到异步 JSON 请求，都可以用到它。
				最终我将展示<b>如何使用你已经知道的 5 个查询函数来查询这个类型的数据。</b>是时候给这个类型起一个名字了...</p>
			<h2>使用 Observables</h2>

			<p>微软的开源库 <a href="http://msdn.microsoft.com/en-us/data/gg577609.aspx">Reactive Extensions</a> 在 Javascript 当中
				引入了一个新的集合类型：<b>Observable</b>。Observable 和事件（Event）很类似。和 Event 一样，
				<b>Observable 是一个由数据产生者<i>推送</i>给数据消费者的值的序列。</b>
				和 Event 不同的是， <b>Observable 可以通知监听者，它已经完成</b>，并且不再发送任何数据。
			</p>

			<p>Observables 可以异步地像消费者发送数据。和数组不同，Javascript 当中没有创建
			 Observable 的字面值语法。不过我们可以通过构造一个助手方法来描述序列的值和每个值到达的时间。
			  <b>seq</b> 函数可以通过数组来构造 Observable，当碰到一个空值时，添加一个时间上的延迟。
			   每个 ,,, 会增加 1 秒的延迟。</p>
			<pre>
				// 一个数字数组 1,2,3
				var numbers123Array =      [1,2,3];

				// 一个序列，先返回 1， 4 秒钟之后返回 2，
				// 再等待 1 秒返回 3，然后结束。
				var numbers123Observable = seq([1,,,,,,,,,,,,2,,,3]);

				// 和数组一样，Observables 可以包含任意对象，甚至数组本身。
				var observableOfArrays = seq([ [1,2,3],,,,,,[4,5,6],,,,,,,,,,,[1,2] ]);
			</pre>
			<p>Observables 是一系列值组成的序列，一个接一个的发送出去。因此 一个 Observable 有可能会一直像监听者发送数据，例如鼠标的移动事件。
				要创建一个不会完成的序列，你可以在 seq() 的参数的末尾添加 ,,, 。</p>
			<pre>
				// 结尾的 ,,, 保证了这个序列 <u>不会</u> 终止。
				var mouseMovesObservable =
					seq([ {x: 23, y: 55},,,,,,,{x: 44, y: 99},,,{x:55,y:99},,,{x: 54, y:543},,, ]);

				// 没有结尾的 ,,, 意味着这个序列 <u>将会</u> 结束。
				var numbers123Observable = seq([1,,,2,,,3]);
			</pre>
			<p>对数组的查询只能给我们提供一个快照。与其对比，对 Observables 的查询允许我们创建一个能够随着时间响应变化而且更新自己的数据集。
				这个特性带来了一个非常强大的编程模型，被称为 <i>响应式（Reactive）编程</i>。</p>

			<p>让我们先从 Observable 和 Events 的对比说起...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 28: 订阅一个事件</h4>

		<p>过去你可以把事件看成是存储在一个对象里的一系列 handler 的 list。在这个例子里，我们订阅一个按钮点击的事件，然后在按钮被点击一次之后，就取消订阅。
		</p>
		<textarea class="code" rows="60" cols="80">
			function(button) {
				// the button click handler
				var handler = function(ev) {
					// Unsubscribe from the button event.
					button.removeEventListener("click", handler);

					alert("Button was clicked. Unsubscribing from event.");
				};

				// add the button click handler
				button.addEventListener("click", handler);
			}
		</textarea>
		<button class="go">运行</button>
		<div class="output" style="text-align:center">
			<button class="button" id="thisfirstbutton">运行程序后点击这个按钮</button>
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					button = $('.button', lesson)[0];

				fun(button);
			}
		</pre>
		<p class="post">问你自己这样一个问题：<b>订阅一个事件和遍历一个数组有什么不同？</b>
			这两个操作都是通过重复调用一个函数，给监听者发送一系列的数据。为什么我们不能使用相同的方式
			遍历数组和事件呢？</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 29: 遍历事件</h4>

		<p>订阅一个事件（Event）和遍历一个数组，本质上是相同的操作。唯一的区别在于，
			<b>数组遍历是同步的，而且一定会结束，而事件的遍历是异步的，同时<u>永远不会结束</u>。</b>
			如果我们把按钮点击事件转换为一个 Observable 对象，我们就可以使用 forEach() 来遍历这个事件。</p>
		<textarea class="code" rows="60" cols="80">
			function(button) {
				var buttonClicks = Observable.fromEvent(button, "click");

				// In the case of an Observable, forEach returns a subscription object.
				var subscription =
					buttonClicks.
						forEach(function(clickEvent) {
							alert("Button was clicked. Stopping Traversal.");

							// Stop traversing the button clicks
							subscription.dispose();
						});
			}
		</textarea>
		<button class="go">运行</button>
		<div class="output" style="text-align:center">
			<button class="button">运行程序后点击这个按钮</button>
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					button = $('.button', lesson)[0];

				fun(button);
			}
		</pre>
		<div class="post">
			<p>注意 <b>Observable 的 forEach() 方法返回了一个 Subscription 对象。</b> 销毁（Dispose）这个 Subscription
				对象会取消对于事件的订阅，防止内存泄露。 销毁 subscription 相当于是异步版本的在循环过程中 break 出去。</p>

			<p>销毁 Subscription 对象基本上和调用 removeEventListener() 是一样的。表面上看来，这两种事件处理的方式并没有那么不同。
				这样看来，为什么我们还要费力去把事件转换成 Observables 呢？原因是，<b>如果我们把事件转换成 Observable，我们就能够
				使用强大的函数操作来对它进行变换。</b> 在下一个练习中，我们将学习如何使用这样的函数，在很多情况下避免对于 Subscriptions 的处理...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>练习 30: 使用 take() 来结束一个序列</h4>

		<p><b>你有没有希望你可以监听一个事件的下一次出现，然后立马取消订阅？</b>
			例如，开发者们经常想订阅 window.onload 事件，同时期望他们的事件处理器只被调用一次。</p>
		<pre>
			window.addEventListener(
				"load",
				function()
					// do some work here, but expect this function will only be called once.
				})
		</pre>
		<p>类似这样的例子当中，当事件发生之后立马取消订阅，是一个很好的习惯。没有正确取消订阅，会导致<b>内存泄露</b>。
			根据实际情况不同，内存泄露有可能严重地影响你的应用的可靠性，而且有可能难以追踪到问题根源。
			不幸的是，取消订阅事件的操作，有时候并不简单：
		</p>
		<pre>
			var handler = function() {
				// do some work here, then unsubscribe from the event
				window.removeEventListener("load", handler)
			};
			window.addEventListener("load", handler);
		</pre>
		<p>如果能有更简单的方式做到这一点，岂不是会更好？这就是为什么 Observable 有一个 take() 方法。
			take() 方法的用法是这样的...
		</p>
		<pre>
			seq([1,,,2,,,3,,,4,,,5,,,6,,,]).take(3) === seq([1,,,2,,,3]);
		</pre>
		<p>基于事件的 Observable <u>永远不会</u>自己结束。 take() 方法会创建一个新的序列，这个序列，在固定数量的元素到达之后，就会结束。
			这是一个很重要的点，因为和事件不同，<i>当一个 Observable 序列结束时，它会自动取消所有的监听者的订阅</i>。 这就意味着，
			<b>如果我们使用 take() 来结束事件序列，我们不再需要手动取消订阅了！</b>
		</p>

		<p>让我们重复前面的练习，在上个练习里，我们监听了一个按钮点击的事件，然后取消订阅。
			这次我们使用 take() 在按钮被点击的时候，结束这个序列。</p>
		<textarea class="code" rows="60" cols="80">
			function(button) {
				var buttonClicks = Observable.fromEvent(button, "click");

				// Use take() to listen for only one button click
				// and unsubscribe.
				buttonClicks.
					// Insert take() call here
					forEach(function(clickEvent) {
						alert("Button was clicked once. Stopping Traversal.");
					});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<div class="output" style="text-align:center">
			<button class="button">运行程序后点击这个按钮</button>
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					button = $('.button', lesson)[0];

				fun(button);
			}
		</pre>
		<pre class="answer">
			function(button) {
				var buttonClicks = Observable.fromEvent(button, "click");

				// Use take() to listen for only one button click
				// and unsubscribe.
				buttonClicks.
					take(1).
					forEach(function(priceRecord) {
						alert("Button was clicked once. Stopping Traversal.");
					});
			}
		</pre>
		<div class="post">
			<p>take() 对于监听固定次数的事件然后取消订阅来说，是一个非常好用的方法，
				然而 Observable 还有 <i>更加</i> 灵活的方法可以用来结束序列...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 31: Completing sequences with takeUntil()</h4>

		<p><b>Have you ever wanted to unsubscribe from one Event when another Event fires?</b> Observable's takeUntil() function
		is a convenient way of completing a sequence when another Event occurs.</b> Here's how takeUntil() works:
		</p>
		<pre>
			var numbersUntilStopButtonPressed =
				seq(              [ 1,,,2,,,3,,,4,,,5,,,6,,,7,,,8,,,9,,, ]).
					takeUntil(seq([  ,,, {eventType: "click"},,, ]) )                    === seq([ 1,,,2 ])
		</pre>
		<p>Earlier we (unknowningly) built a dynamic Microsoft price stock ticker using Observable. The problem with that stock
			ticker was that <i>it kept going on forever</i>. If left unchecked, all the entries in the log could use up all of
			the memory on the page. In the exercise below, filter the Observable sequence of NASDAQ prices for MSFT stock
			prices, use the fromEvent() function to create an Observable .
		</p>
		<textarea class="code" rows="60" cols="80">
			function(pricesNASDAQ, printRecord, stopButton) {
				var stopButtonClicks = // ----- To finish this expression, use Observable.fromEvent to convert the "click" event on the stop button to an Observable
					microsoftPrices =
						pricesNASDAQ.
							filter(function(priceRecord) {
								return priceRecord.name === "MSFT";
							}).
							// ----- To finish this expression, use takeUntil to complete the sequence when stopButtonClicks fires.

				microsoftPrices.
					forEach(function(priceRecord) {
						printRecord(priceRecord);
					});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<button class="stop">Stop</button>
		&lt;-Press this button to complete the sequence of microsoft stock prices.
		<p>Console</p>

		<div class="output" style="height:200px;overflow:scroll">
		</div>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					output = $(".output", lesson)[0],
					stopButton = $('.stop', lesson)[0],
					stockSymbols = ["MSFT", "GOOG","NFLX","OSTK"],
					input = [{name: "MSFT", price: 32.32, timeStamp: new Date() }, {name: "GOOG", price: 150.43, timeStamp: new Date(2011,11,15)}],
					expected = [input[0]],
					items = [],
					counter = 0,
					print = function(item) {
						output.innerHTML += "MSFT " + item.price + " at " + item.timeStamp.toString() + "<" + "br" + ">";
						output.scrollTop = output.scrollHeight;
						counter++;
						if (counter % 100 === 0) {
							output.innerHTML = "";
						}
					},
					stocks =
						Rx.Observable.
							interval(250).
							map(function() {
								var symbol = stockSymbols[Math.floor(Math.random() * stockSymbols.length)];
								return {name: symbol, price: 30 + ((Math.floor(Math.random() * 100))/200), timeStamp: new Date()};
							});

				fun(stocks, print, stopButton);
			}
		</pre>
		<pre class="answer">
			function(pricesNASDAQ, printRecord, stopButton) {
				var stopButtonClicks = Observable.fromEvent(stopButton,"click"),
					microsoftPrices =
						pricesNASDAQ.
							filter(function(priceRecord) {
								return priceRecord.name === "MSFT";
							}).
							takeUntil(stopButtonClicks);

				microsoftPrices.
					forEach(function(priceRecord) {
						printRecord(priceRecord);
					});
			}
		</pre>
		<div class="post">
			<p>We've learned that Observable sequences are much more powerful than raw events, because they can complete. <b>The
				take() and takeUntil() functions are powerful enough to ensure that we never have to unsubscribe from another event
				again!</b> This reduces the risk of memory leaks and makes our code more readable.
			</p>

			<p>Here's what we learned in this section:</p>
			<ul>
				<li>We can traverse Observables using forEach().</li>
				<li>We can use fromEvent() to convert Events into Observables that never complete.</li>
				<li>We can apply take() and takeUntil() to an Observable to create a new sequence which <i>does</i> complete.</li>
			</ul>
			<p>In the next section we'll learn how to combine events to create more complex events. You'll be suprised how easily
				you can solve complex, asynchronous problems!
			</p>

			<h3>Querying Observables</h3>

			<p>What's the difference between these two tasks?</p>
			<ul>
				<li>Creating a flat list of movies with a rating of 5.0 from a bunch of movie lists.</li>
				<li>Creating a sequence of all the mouse drag events from the mouseDown, mouseMove, and mouseUp events.</li>
			</ul>
			<p>You might think of them as different, and might code them very differently, but <b>these tasks are fundamentally the
				same.</b> Both of these tasks are <i>queries</i>, and can be solved using the functions you've learned in these
				exercises.
			</p>

			<p><b>The difference between traversing an Array and traversing an Observable is <i>the direction in which the data
				moves.</i></b> When traversing an Array, the client <i>pulls</i> data from the data source, blocking until it gets a
				result. When traversing Observables, the data source <i>pushes</i> data at the client whenever it arrives.
			</p>

			<p>It turns out that the direction in which data moves is <i>orthogonal</i> to querying that data. In other words, <b>when
				we're querying data it doesn't matter whether we pull data, or data is pushed at us.</b> In either case the query
				methods make the same transformations. The only thing that changes is the input and output type respectively. If we
				filter an Array, we get a new Array. If we filter an Observable, we get a new Observable, and so on.
			</p>

			<p>Take a look at how the query methods transform Observables and Arrays:</p>
			<pre>
				// <b>map()</b>

				[1,2,3].map(function(x) { return x + 1 })                       === [2,3,4]
				seq([1,,,2,,,3]).map(function(x) { return x + 1})               === seq([2,,,3,,,4])
				seq([1,,,2,,,3,,,]).map(function(x) { return x + 1 })           === seq([2,,,3,,,4,,,])

				// <b>filter()</b>

				[1,2,3].filter(function(x) { return x > 1; })                   === [2,3]
				seq([1,,,2,,,3]).filter(function(x) { return x > 1; })          === seq([2,,,3])
				seq([1,,,2,,,3,,,]).filter(function(x) { return x > 1; })       === seq([2,,,3,,,])

				// <b>concatAll()</b>

				[ [1, 2, 3], [4, 5, 6] ].concatAll()                             === [1,2,3,4,5,6]
				seq([ seq([1,,,2,,,3]),,,seq([4,,,5,,,6]) ]).concatAll()         === seq([1,,,2,,,3,,,4,,,5,,,6])

				// If a new sequence arrives before all the items
				// from the previous sequence have arrived, no attempt
				// to retrieve the new sequence's elements is made until
				// the previous sequence has completed. As a result the
				// order of elements in the sequence is preserved.
				seq([
					seq([1,,,, ,2, ,3])
					,,,seq([,,4, ,5, ,,6]) ]).
					concatAll()                                                  === seq([1,,,,,2,,3,,4,,5,,,6])

				// Notice that as long as at least one sequence being
				// concatenated is incomplete, the concatenated sequence is also
				// incomplete.
				seq([
					seq([1,, ,,, ,,,2,,,3])
					,,,seq([4,,,5,,, ,,, ,,6,,,]) ]).
					concatAll()                                                  === seq([1,,,4,,,5,,,2,,,3,,,6,,,])

				// <b>reduce()</b>

				[ 1, 2, 3 ].reduce(sumFunction)                                 === [ 6 ]
				seq([ 1,,,2,,,3 ]).reduce(sumFunction)                          === seq([,,,,,,6])

				// Reduced sequences do <u>not</u> complete until the
				// sequence does.
				seq([ 1,,,2,,,3,,, ]).reduce(sumFunction)                       === seq([ ,,,,,,,,,])

				// <b>zip()</b>

				// In both Arrays and Observables, the zipped sequence
				// completes as soon as either the left or right-hand
				// side sequence completes.
				Array.zip([1,2],[3,4,5], sumFunction)                           === [4,6]
				Observable.zip(seq([1,,,2]),seq([3,,,4,,,5]), sumFunction)      === seq([4,,,6])

				// <b>take()</b>
				[1,2,3].take(2)                                                 === [1, 2]
				seq([ 1,,,2,,,3 ]).take(2)                                      === seq([ 1,,,2 ])
				seq([ 1,,,2,,,3,,, ]).take(2)                                   === seq([ 1,,,2 ])

				// <b>takeUntil()</b>

				// takeUntil works for Arrays, but it's not very useful
				// because the result will always be an empty array.
				[1,2,3].takeUntil([1])                                          === []

				seq([1,,,2,,,3,,, ]).takeUntil(
				seq([ ,,, ,,4 , }))                                             === seq([ 1,,,2 ])

			</pre>
			<p>Remember when I <a href="#indexers">prohibited the use of array indexers?</a> The reason for that restriction should
				now become clearer to you. Whereas the 5 functions can be used on <i>any</i> collection, indexers can only be used
				on collections that support random-access (like Array). If you avoid indexers and stick to the functions you've
				learned in this tutorial, you'll have a unified programming model for transforming <i>any</i> collection. Having a
				unified programming model makes it trivial to convert synchronous code to asynchronous code, a process which would
				otherwise be very difficult. As we've demonstrated, you don't need indexers to perform complex collection
				transformations.</p>

			<p>Now that we've seen that we can query asychronous and synchronous data sources using the same programming model,
				let's use Observable and our query functions to create complex new events.</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 32: Creating a mouse drag event</h4>

		<p>Remember the exercise we solved earlier? The one in which we retrieved all the movies with a rating of 5.0 from
			an array of movie lists? If we were to describe the solution in pseudocode it might read something like
			this...
		</p>

		<p><b>"For every movie list, retrieve only those videos with a rating of 5.0"</b></p>
		<pre>
			var moviesWithHighRatings =
				movieLists.
					concatMap(function(movieList) {
						return movieList.videos.
							filter(function(video) {
								return video.rating === 5.0;
							});
					});
		</pre>
		<p>Now we're going to create a mouseDrag event for a DOM object. If we were to describe <i>this</i> problem as
			pseudocode it might read something like this...
		</p>

		<p><b>"For every
			<del>movie list</del>
			mouse down event on the sprite, retrieve only those
			<del>videos with a rating of 5.0</del>
			mouse move events that occur before the next mouse up event."</b>
		</p>
		</p>
		<textarea class="code" rows="60" cols="80">
			function(sprite, spriteContainer) {
				var spriteMouseDowns = Observable.fromEvent(sprite, "mousedown"),
					spriteContainerMouseMoves = Observable.fromEvent(spriteContainer, "mousemove"),
					spriteContainerMouseUps = Observable.fromEvent(spriteContainer, "mouseup"),
					spriteMouseDrags =
						// For every mouse down event on the sprite...
						spriteMouseDowns.
							// --------------------------------------------------------
							//					  INSERT CODE HERE
							// --------------------------------------------------------
							// Complete this expression...
							// For every mouse down event, return the mouse move event
							// sequence until a mouse up event occurs.

				// For each mouse drag event, move the sprite to the absolute page position.
				spriteMouseDrags.forEach(function(dragPoint) {
					sprite.style.left = dragPoint.pageX + "px";
					sprite.style.top = dragPoint.pageY + "px";
				});
			}
		</textarea>
		<button class="go">运行</button>
		<!-- <button class="showAnswer">显示答案</button> -->
		<button class="resetSprite">Reset Sprite</button>
		<div class="control output container" style="height:200px;text-align:center">
            <span class="control sprite" style="position:absolute; border: solid 1px black; background-color: white;z-index:23">
                Sprite
            </span>
			<span style="position:relative; top: 100px;">Sprite Container</span>
		</div>

		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					output = $(".output", lesson)[0],
					container = $(".container", lesson)[0],
					sprite = $(".sprite",lesson)[0],
					moveSprite = function(point) {
						sprite.style.left = point.pageX + "px";
						sprite.style.top = point.pageY + "px";
					}

				fun(sprite, container, moveSprite);
			}
		</pre>
		<pre class="answer">
			function(sprite, spriteContainer) {
				var spriteMouseDowns = Observable.fromEvent(sprite, "mousedown"),
					spriteContainerMouseMoves = Observable.fromEvent(spriteContainer, "mousemove"),
					spriteContainerMouseUps = Observable.fromEvent(spriteContainer, "mouseup"),
					spriteMouseDrags =
						// For every mouse down event on the sprite...
						spriteMouseDowns.
							concatMap(function(contactPoint) {
								// ...retrieve all the mouse move events on the sprite container...
								return spriteContainerMouseMoves.
									// ...until a mouse up event occurs.
									takeUntil(spriteContainerMouseUps);
							});

				// For each mouse drag event, move the sprite to the absolute page position.
				spriteMouseDrags.forEach(function(dragPoint) {
					sprite.style.left = dragPoint.pageX + "px";
					sprite.style.top = dragPoint.pageY + "px";
				});
			}
        </pre>
		<p class="post">Now we're really cooking. We just created a complex event with a few lines of code. We didn't have to
			deal with any subscriptions objects, or write any stateful code whatsoever. Let's try something a little
			harder.</p>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 33: Improving our mouse drag event</h4>

		<p>Our mouse drag event is a little <i>too</i> simple. Notice that when we drag around the sprite, it always
			positions itself at the top-left corner of the mouse. Ideally we'd like our drag event to offset its
			coordinates, based on where the mouse was when the mouse down event occurred. This will make our mouse drag more
			closely resemble moving a real object with our finger.
		</p>

		<p>Let's see if you can adjust the coordinates in the mouse drag event, based on the mousedown location on the
			sprite. The mouse events are sequences, and they look something like this:
		</p>

		<pre>
			spriteContainerMouseMoves =
				seq([ {x: 200, y: 400, offsetX: 10, offsetY: 15},,,{x: 210, y: 410, offsetX: 20, offsetY: 26},,, ])
		</pre>
		<p>
			Each item in the mouse event sequences contains an x, y value that represents that absolute location of the
			mouse event on the page. The moveSprite() function uses these coordinates to position the sprite. Each item in
			the sequence <i>also</i> contains a pair of offsetX and offsetY properties that indicate the position of the
			mouse event relative to the event target.
		</p>

		<textarea class="code" rows="60" cols="80">
			function(sprite, spriteContainer) {
				// All of the mouse event sequences look like this:
				// seq([ {pageX: 22, pageY: 3423, offsetX: 14, offsetY: 22} ,,, ])
				var spriteMouseDowns = Observable.fromEvent(sprite, "mousedown"),
					spriteContainerMouseMoves = Observable.fromEvent(spriteContainer, "mousemove"),
					spriteContainerMouseUps = Observable.fromEvent(spriteContainer, "mouseup"),
					// Create a sequence that looks like this:
					// seq([ {pageX: 22, pageY:4080 },,,{pageX: 24, pageY: 4082},,, ])
					spriteMouseDrags =
						// For every mouse down event on the sprite...
						spriteMouseDowns.
							concatMap(function(contactPoint) {
								// ...retrieve all the mouse move events on the sprite container...
								return spriteContainerMouseMoves.
									// ...until a mouse up event occurs.
									takeUntil(spriteContainerMouseUps).
									// ------------   INSERT CODE HERE  -----------------
									// Project each mouse move object into a new object
									// with adjusted pageX and pageY properties.
									// Translate each page coordinate based on the value
									// of the offsetX and offsetY properties in the
									// contactPoint.
									// -------------------------------------------------
									// Complete expression...
							});

				// For each mouse drag event, move the sprite to the absolute page position.
				spriteMouseDrags.forEach(function(dragPoint) {
					sprite.style.left = dragPoint.pageX + "px";
					sprite.style.top = dragPoint.pageY + "px";
				});
			}
		</textarea>
		<button class="go">运行</button>
		<button class="showAnswer">显示答案</button>
		<button class="resetSprite">Reset Sprite</button>
		<div class="control output container" style="height:200px;text-align:center">
            <span class="control sprite" style="position:absolute; border: solid 1px black; background-color: white;z-index:23">
                Sprite
            </span>
			<span style="position:relative; top: 100px;">Sprite Container</span>
		</div>

		<pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					output = $(".output", lesson)[0],
					container = $(".container", lesson)[0],
					sprite = $(".sprite",lesson)[0],
					moveSprite = function(point) {
						sprite.style.left = point.pageX + "px";
						sprite.style.top = point.pageY + "px";
					}

				fun(sprite, container, moveSprite);
			}
		</pre>
		<pre class="answer">
			function(sprite, spriteContainer) {
				// All of the mouse event sequences look like this:
				// seq([ {pageX: 22, pageY: 3423, offsetX: 14, offsetY: 22} ,,, ])
				var spriteMouseDowns = Observable.fromEvent(sprite, "mousedown"),
					spriteContainerMouseMoves = Observable.fromEvent(spriteContainer, "mousemove"),
					spriteContainerMouseUps = Observable.fromEvent(spriteContainer, "mouseup"),
					// Create a sequence that looks like this:
					// seq([ {pageX: 22, pageY:4080 },,,{pageX: 24, pageY: 4082},,, ])
					spriteMouseDrags =
						// For every mouse down event on the sprite...
						spriteMouseDowns.
							concatMap(function(contactPoint) {
								// ...retrieve all the mouse move events on the sprite container...
								return spriteContainerMouseMoves.
									// ...until a mouse up event occurs.
									takeUntil(spriteContainerMouseUps).
									map(function(movePoint) {
										return {
											pageX: movePoint.pageX - contactPoint.offsetX,
											pageY: movePoint.pageY - contactPoint.offsetY
										};
									});
							});

				// For each mouse drag event, move the sprite to the absolute page position.
				spriteMouseDrags.forEach(function(dragPoint) {
					sprite.style.left = dragPoint.pageX + "px";
					sprite.style.top = dragPoint.pageY + "px";
				});
			}
        </pre>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 34: HTTP requests</h4>

		<p>Events aren't the only source of asynchronous data in an application. There's also HTTP requests. Most of the
			time HTTP requests are exposed via a <b>callback-based API</b>. To receive data asynchronously from a
			callback-based API, the client typically passes a success and error handler to the function. When the
			asynchronous operation completes, the appropriate handler is called with the data. In this exercise we'll use
			jQuery's getJSON api to asynchronously retrieve data.
		</p>
		<textarea class="code" rows="60" cols="80">
			function($) {
				$.getJSON(
					"http://api-global.netflix.com/queue",
					{
						success: function(json) {
							alert("Data has arrived.");
						},
						error: function(ex) {
							alert("There was an error.")
						}
					});
			}
		</textarea>
		<button class="go">运行</button>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")");
				fun(jQueryMock);
			}
		</pre>
		<div class="post">
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 35: Sequencing HTTP requests with callbacks</h4>

		<p>Let's say that we're writing the startup flow for a web application. On startup, the application must perform the
			following operations:</p>
		<ol>
			<li>Download the URL prefix to use for all subsequent AJAX calls. This URL prefix will vary based on what AB
				test the user is enrolled in.
			</li>
			<li>Use the url prefix to do the following actions in parallel:
				<ul>
					<li>Retrieve a movie list array</li>
					<li>Retrieve configuration information and...
						<ul>
							<li>make a follow up call for an instant queue list if the config property "showInstantQueue" is
								truthy
							</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>If an instant queue list was retrieved, append it to the end of movie list.</li>
			<li>If all operations were successful then display the movie lists <i>after</i> the window loads. Otherwise
				inform the user that there was a connectivity error.
			</li>
		</ol>
		<textarea class="code" rows="60" cols="80">
			function(window, $, showMovieLists, showError) {
				var error,
					configDone,
					movieLists,
					queueList,
					windowLoaded,
					outputDisplayed,
					errorHandler = function() {
						// Otherwise show the error.
						error = "There was a connectivity error";

						// We may be ready to display out
						tryToDisplayOutput();
					},
					tryToDisplayOutput = function() {
						if (outputDisplayed) {
							return;
						}
						if (windowLoaded) {
							if (configDone && movieLists !== undefined) {
								if (queueList !== undefined) {
									movieLists.push(queueList);
								}
								outputDisplayed = true;
								showMovieLists(JSON.stringify(movieLists));
							}
							else if (error) {
								outputDisplayed = true;
								showError(error);
							}
						}
					},
					windowLoadHandler = function() {
						windowLoaded = true;

						// Remember to unsubscribe from events
						window.removeEventListener("load", windowLoadHandler);

						// This may be the last task we're waiting on, so try and display output.
						tryToDisplayOutput();
					};

				// Register for the load event
				window.addEventListener("load", windowLoadHandler);

				// Request the service url prefix for the users AB test
				$.getJSON(
					"http://api-global.netflix.com/abTestInformation",
					{
						success: function(abTestInformation) {
							// Request the member's config information to determine whether their instant
							// queue should be displayed.
							$.getJSON(
								"http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/config",
								{
									success: function(config) {
										// Parallel retrieval of movie list could've failed,
										// in which case we don't want to issue this call.
										if (!error) {
											// If we're supposed to
											if (config.showInstantQueue) {
												$.getJSON(
													"http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/queue",
													{
														success: function(queueMessage) {
															queueList = queueMessage.list;

															configDone = true;
															tryToDisplayOutput();
														},
														error: errorHandler
													});
											}
											else {
												configDone = true;
												tryToDisplayOutput();
											}
										}
									},
									error: errorHandler
								});

							// Retrieve the movie list
							$.getJSON(
								"http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/movieLists",
								{
									success: function(movieListMessage) {
										movieLists = movieListMessage.list;
										tryToDisplayOutput();
									},
									error: errorHandler
								});
						},
						error: errorHandler
					});
			}
		</textarea>
		<button class="go">运行</button>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					NOOP = function() {};

				fun(
					{
						addEventListener: function(event, handler) {
							window.setTimeout(handler, 200)
						},
						removeEventListener: NOOP
					},
					jQueryMock,
					function(output) { alert(output) },
					function(output) { alert(output) });
			}
		</pre>
		<div class="post">
			<p>It's fair to say that <b>sequencing HTTP requests with callbacks is <i>very</i> hard.</b> In order to perform
				two tasks in parallel, we have to introduce a variable to track the status of each task. Every time one of
				the parallel tasks completes it must check whether its sibling task has also completed. If both have
				completed, only then can we move forward. In the example above, every time a task is finished the
				tryToDisplayOutput() function is called to check if the program was ready to display output. This function
				checks the status of all tasks and displays the output if possible.
			</p>

			<p>With a callback-based API, asynchronous error handling is also very complicated. In synchronous programs, a
				unit of work is cancelled when an exception is thrown. By contrast, in our program we had to explicitly
				track whether an error occurred in parallel to prevent an unnecessary call for the instant queue. Javascript
				provides us with special support for synchronous error handling with the keywords try/catch/throw.
				Unfortunately no such support is available for asynchronous programs.
			</p>

			<p>The Observable interface is a much more powerful way of working with asynchronous APIs than callbacks. We'll
				see that Observables can free us from having to track the status of tasks that are run in parallel, just
				Observables frees us from having to track Event Subscriptions. We'll also see that Observable gives us the
				same error propagation semantics in asynchronous programs that we expect in synchronous programs. Finally
				we'll learn that by converting callback-based APIs to Observables, we can query them along with Events to
				build much more expressive programs.
			</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 36: Traversing callback-based Asynchronous APIs</h4>

		<p><b>If a callback API were a sequence, what kind of sequence would it be?</b> We've seen that UI Event sequences
			can contain anywhere from 0 to infinite items, but will never complete on their own.
		</p>
		<pre>
			mouseMoves === seq([ {x: 23, y: 55},,,,,,,{x: 44, y: 99},,,{x:55,y:99},,,{x: 54, y:543},,, ]);
		</pre>
		<p>In contrast, if we were to convert output from the $.getJSON() function we've been using into a sequence it would
			always return a sequence that completes after sending a single item.
		</p>
		<pre>
			getJSONAsObservable("http://api-global.netflix.com/abTestInformation") ===
				seq([ { urlPrefix: "billboardTest" } ])
		</pre>
		<p>It might seem strange to create sequences that contain only one object. We <i>could</i> introduce an
			Observable-like type specifically for scalar values, but that would make callback-based APIs more difficult to
			query with Events. Thankfully, an Observable sequence is flexible enough to model both.
		</p>

		<p><b>So how do we convert a callback API into an Observable sequence?</b> Unfortunately, because callback-based
			APIs vary so much in their interfaces, we can't create a conversion function like we did with fromEvent().
			However there is a more flexible function we can use to build Observable sequences...
		</p>

		<p><b>Observable.create() is powerful enough to convert any asynchronous API into an Observable.</b>
			Observable.create() relies on the fact that all asynchronous APIs have the following semantics:
		</p>
		<ol>
			<li>The client needs to be able to receive data.</li>
			<li>The client needs to be able to receive error information.</li>
			<li>The client needs to be able to be alerted that the operation is complete.</li>
			<li>The client needs to be able to indicate that they're no longer interested in the result of the operation.</li>
		</ol>
		<p>In the following example, we'll use the Observable.create() function to create an Observable that issues a
			request to getJSON when it's traversed.
		</p>
		<textarea class="code" rows="60" cols="80">
			function(window, $) {
				var getJSON = function(url) {
					return Observable.create(function(observer) {
						var subscribed = true;

						$.getJSON(url,
							{
								success:
									function(data) {
										// If client is still interested in the results, send them.
										if (subscribed) {
											// Send data to the client
											observer.onNext(data);
											// Immediately complete the sequence
											observer.onCompleted();
										}
									},
								error: function(ex) {
									// If client is still interested in the results, send them.
									if (subscribed) {
										// Inform the client that an error occurred.
										observer.onError(ex);
									}
								}
							});

						// Definition of the Subscription objects dispose() method.
						return function() {
							subscribed = false;
						}
					});
				};

				var subscription =
					getJSON("http://api-global.netflix.com/abTestInformation").
						forEach(
							// observer.onNext()
							function(data) {
								alert(JSON.stringify(data));
							},
							// observer.onError()
							function(err) {
								alert(err)
							},
							// observer.onCompleted()
							function() {
								alert("The asynchronous operation has completed.")
							});
			}
		</textarea>
		<button class="go">运行</button>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					NOOP = function() {};

				fun(
					{
						addEventListener: function(event, handler) {
							window.setTimeout(handler, 200)
						},
						removeEventListener: NOOP
					},
					jQueryMock,
					function(output) { alert(output) },
					function(output) { alert(output) });
			}
		</pre>
		<div class="post">
			<p>Understand that <b>the function passed to Observable.create() is the definition of the forEach() function for
				<i>this</i> Observable.</b> In other words, all we have to do to define an Observable is to define its
				traversal function. Notice that although we pass three functions to the Observable's forEach() function, the
				function we pass to Observable.create() accepts only one value: an Observer. An Observer is just a triple
				containing three handlers:</p>
			<ul>
				<li>The onNext() handler used to send data to the client.</li>
				<li>The onError() handler used to send error information to the client.</li>
				<li>The onCompleted() handler used to inform the client that the sequence has completed.</li>
			</ul>
			<p>The three handlers we pass to forEach() are packaged together into a single Observer object for convenience.
				Finally Observable.create() returns a function that defines the dispose() method of the Subscription object
				during Traversal. Like the Observer, the Observable.create() function creates the Subscription object for us
				and uses our function as the dispose() definition.</p>

			<p>Now that we've built a version of the getJSON function that returns an Observable sequence, let's use it to
				improve our solution to the previous exercise...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 37: Sequencing HTTP requests with Observable</h4>

		<p>Let's use the getJSON function that returns Observables, and the Observable.fromEvent() to complete the exercise
			we completed earlier.</p>
		<textarea class="code" rows="60" cols="80">
			function(window, getJSON, showMovieLists, showError) {
				var movieListsSequence =
					Observable.zip(
						getJSON("http://api-global.netflix.com/abTestInformation").
							concatMap(function(abTestInformation) {
								return Observable.zip(
									getJSON("http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/config").
										concatMap(function(config) {
											if (config.showInstantQueue) {
												return getJSON("http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/queue").
													map(function(queueMessage) {
														return queueMessage.list;
													});
											}
											else {
												return Observable.returnValue(undefined);
											}
										}),
									getJSON("http://api-global.netflix.com/" + abTestInformation.urlPrefix + "/movieLists"),
									function(queue, movieListsMessage) {
										var copyOfMovieLists = Object.create(movieListsMessage.list);
										if (queue !== undefined) {
											copyOfMovieLists.push(queue);
										}

										return copyOfMovieLists;
									});
							}),
						Observable.fromEvent(window, "load"),
						function(movieLists, loadEvent) {
							return movieLists;
						});

				movieListsSequence.
					forEach(
						function(movieLists) {
							showMovieLists(movieLists);
						},
						function(err) {
							showError(err);
						});
			}
		</textarea>
		<button class="go">运行</button>
		<pre class="verifier">
			// Combine videos and bookmarks 2
			function(str, lesson) {
				preVerifierHook();
				var fun = eval("(" + str + ")"),
					getJSON = function(url) {
						return Observable.create(function(observer) {
							var subscribed = true;

							jQueryMock.getJSON(url,
								{
									success:
										function(data) {
											// If client is still interested in the results, send them.
											if (subscribed) {
												// Send data to the client
												observer.onNext(data);
												// Immediately complete the sequence
												observer.onCompleted();
											}
										},
									error: function(ex) {
										// If client is still interested in the results, send them.
										if (subscribed) {
											// Inform the client that an error occurred.
											observer.onError(ex);
										}
									}
								});

							// Definition of the Subscription objects dispose() method.
							return function() {
								subscribed = false;
							}
						})
					},
					NOOP = function() {};

				fun(
					{
						addEventListener: function(event, handler) {
							window.setTimeout(handler, 200)
						},
						removeEventListener: NOOP
					},
					getJSON,
					function(output) { alert(JSON.stringify(output)) },
					function(output) { alert(output) });
			}
		</pre>
		<div class="post">
			<p>Almost every workflow in a web application starts with an event, continues with an HTTP request, and results
				in a state change. Now we know how to express the first two tasks elegantly.</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 38: Throttle Input</h4>

		<p>When dealing with user input, there will be times when the user's input is too noisy, and will potentially clog
			your servers with extraneous requests. We want the ability to throttle the users's input so that if they
			interacting for one second, then we will get the user input. Let's say for example, the user clicks a button
			once too many times upon saving and we only want to fire after they've stopped for a second.</p>
		<pre>
			seq([1,2,3,,,,,,,4,5,6,,,]).throttle(1000 /* ms */) === seq([,,,,,,,3,,,,,,,,,,6,,,]);
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (clicks, saveData, name) {
				return clicks.
					// TODO: Throttle the clicks so that it only happens every one second
					concatMap(function () {
						return saveData(name);
					});
			}
		</textarea>

		<button class="go">运行</button>
		<label for="inputName">Name</label>
		<input type="text" class="inputName"><strong class="savedValue"></strong>
		<button class="submitInputName">Save</button> <<-- Click this to save your data

		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var $inputName = $('.inputName', lesson),
					$savedValue = $('.savedValue', lesson);

				var counter = 0;
				var data = null;
				var clicks = Observable.fromEvent($('.submitInputName', lesson)[0], 'click');

				var code =  eval("(" + str + ")")
				var code = code(clicks, function(name) { return Rx.Observable.returnValue(name.val()); }, $inputName);

				code
					.subscribe(function (data) {
						$savedValue.text('Name Saved: ' + data);
					});
			}
		</pre>
        <pre class="answer">
			function (clicks, saveData, name) {
				return clicks.
					throttle(1000).
					concatMap(function () {
						return saveData(name);
					})
			}
        </pre>
		<div class="post">
			<p>Now that we know how to throttle input, let's take a look at another problem where throttling data is
				important...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 39: Autocomplete Box</h4>

		<p>One of the most common problems in web development is the autocomplete box. This seems like it should be an easy
			problem, but is actually quite challenging. For example, how do we throttle the input? How do we make sure we're
			not getting out of order requests coming back? For example if I type "react" then type "reactive" I want
			"reactive" to be my result, regardless of which actually returned first from the service.</p>

		<p>In the example below, you will be receiving a sequence of key presses, a textbox, and a function when called
			returns an array of search results.</p>
		<pre>
			getSearchResultSet('react') === seq[,,,["reactive", "reaction","reactor"]]
			keyPresses === seq['r',,,,,'e',,,,,,'a',,,,'c',,,,'t',,,,,]
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (getSearchResultSet, keyPresses, textBox) {

				var getSearchResultSets =
					keyPresses.
					map(function () {
						return textBox.value;
					}).
					// TODO: Ensure that we only trigger a maximum of one search request per second
					concatMap(function (text) {

					// TODO: Ensure this sequence ends as soon as another key press arrives
					return getSearchResultSet(text);
				});

				return getSearchResultSets;
			}
		</textarea>

		<button class="go">运行</button>

		<label for="inputName">Name</label>
		<input type="text" class="inputName">

		<ul class="searchResultsForAutoComplete"></ul>

		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var wordlist = window.wordlist;
				wordlist.sort();

				var searchText = function (text) {

					var matched = wordlist.filter(function (x) {
						return x.indexOf(text) === 0;
					});

					return Rx.Observable.returnValue(
						matched.slice(0, 10)
					);
				};

				var $inputName = $('.inputName', lesson)[0],
					$searchResults = $('.searchResultsForAutoComplete', lesson);

				var clicks = Rx.Observable.fromEvent($inputName, 'keyup');

				var code =  eval("(" + str + ")")
				var code = code(searchText, clicks, $inputName);

				code
					.subscribe(function (results) {
						var s = results.map(function (r) {
							return '&lt;li&gt;' + r + '&lt;/li&gt;';
						});
						$searchResults.html(s.join(''));
					});
			}
		</pre>
        <pre class="answer">
			function (getSearchResultSet, keyPresses, textBox) {

				var getSearchResultSets =
					keyPresses.
						map(function () {
							return textBox.value;
						}).
						throttle(1000).
						concatMap(function (text) {
							return getSearchResultSet(text).takeUntil(keyPresses);
						});

				return getSearchResultSets;
			}
        </pre>
		<div class="post">
			<p>Now that we're able to query with our throttled input, you'll still notice one slight problem. If you hit
				your arrow keys or any other non character key, the request will still fire. How do we prevent that?</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 40: Distinct Until Changed Input</h4>

		<p>You'll notice in the previous exercise that if you pressed your arrow keys while inside the textbox, the query
			will still fire, regardless of whether the text actually changed or not. How do we prevent that? The
			distinctUntilChanged filters out successive repetitive values.</p>
		<pre>
			seq([1,,,1,,,3,,,3,,,5,,,1,,,]).distinctUntilChanged() ===
			seq([1,,,,,,,3,,,,,,,5,,,1,,,]);
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (keyPresses, isAlpha) {

				return keyPresses.
					map(function (e) { return String.fromCharCode(e.keyCode); }).

					// Ensure we only have alphabetic characters
					filter(function (character) { return isAlpha(character); }).

					// TODO: Filter out successive repetitive keys

					// Building up a string of all the characters typed.
					scan('', function (stringSoFar, character) {
						return stringSoFar + character;
					});
			}
		</textarea>

		<button class="go">运行</button>

		<label for="inputName">Enter Keys</label>
		<input type="text" class="inputName">
		<div>Keys filtered by distinctUntilChanged: <strong class="filteredKeysByDistinct"></strong></div>
		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var $inputName = $('.inputName', lesson),
					$filtered = $('.filteredKeysByDistinct', lesson);

				var keyups = Rx.Observable.fromEvent($inputName[0], 'keypress');

				var isAlpha = function (x) {
					return 'abcdefghijklmnopqrstuvwxyz'.indexOf(x.toLowerCase()) !== -1;
				};

				var code =  eval("(" + str + ")")
				var code = code(keyups, isAlpha);

				code
					.subscribe(function (text) {
						$filtered.text(text);
					});
			}
		</pre>
        <pre class="answer">
			function (keyPresses, isAlpha) {

				return keyPresses.
					map(function (e) { return String.fromCharCode(e.keyCode); }).
					filter(function (character) { return isAlpha(character); }).
					distinctUntilChanged().
					scan('', function (stringSoFar, character) {
						return stringSoFar + character;
					});
			}
        </pre>
		<div class="post">
			<p>Now that we know how to get only the distinct input, let's see how it applies to our autocomplete
				example...</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 41: Autocomplete Box Part 2: Electric Boogaloo</h4>

		<p>In the previous version of the autocomplete box, there were two bugs</p>
		<ul>
			<li>Multiple successive searches are made for the same string</li>
			<li>Attempts are made to retrieve results for an empty string.</li>
		</ul>

		<p>The example below is the same as above, but this time, fix the bugs!</p>
		<pre>
			getSearchResultSet('react') === seq[,,,["reactive", "reaction","reactor"]]
			keyPresses === seq['r',,,,,'e',,,,,,'a',,,,'c',,,,'t',,,,,]
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (getSearchResultSet, keyPresses, textBox) {

				var getSearchResultSets =
					keyPresses.
						map(function () {
							return textBox.value;
						}).
						throttle(1000).

						// TODO: Make sure we only get distinct values

						// TODO: Make sure the text is not empty

						concatMap(function (text) {
							return getSearchResultSet(text).takeUntil(keyPresses);
						});

				return getSearchResultSets;
			}
		</textarea>

		<button class="go">运行</button>
		<label for="inputName">Name</label>
		<input type="text" class="inputName">

		<ul class="searchResultsForAutoComplete"></ul>
		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var wordlist = window.wordlist;
				wordlist.sort();

				var searchText = function (text) {

					var matched = wordlist.filter(function (x) {
						return x.indexOf(text) === 0;
					});

					return Rx.Observable.returnValue(
						matched.slice(0, 10)
					);
				};

				var $inputName = $('.inputName', lesson),
					$searchResults = $('.searchResultsForAutoComplete', lesson);

				var clicks = Rx.Observable.fromEvent($inputName[0], 'keyup');

				var code =  eval("(" + str + ")")
				var code = code(searchText, clicks, $inputName[0]);

				code
					.subscribe(function (results) {
						var s = results.map(function (r) {
							return '&lt;li&gt;' + r + '&lt;/li&gt;';
						});
						$searchResults.html(s.join(''));
					});
			}
		</pre>
        <pre class="answer">
			function (getSearchResultSet, keyPresses, textBox) {

				var getSearchResultSets =
					keyPresses.
						map(function () {
							return textBox.value;
						}).
						throttle(1000).
						distinctUntilChanged().
						filter(function (s) { return s.length > 0; }).
						concatMap(function (text) {
							return getSearchResultSet(text).takeUntil(keyPresses);
						});

				return getSearchResultSets;
			}
        </pre>
		<div class="post">
			<p>With just this little amount of code, we're able to produce a fully functioning autocomplete scenario. But
				there are other outstanding questions, such as error handling. How can we handle failure and retry if
				necessary?</p>
		</div>
	</div>




	<!-- ************************* LESSON ************************* -->
	<div class="lesson">
		<h4>Exercise 42: Retrying after errors</h4>

		<p>You'll notice in the previous exercise that if you pressed your arrow keys while inside the textbox, the query
			will still fire, regardless of whether the text actually changed or not. How do we prevent that? The
			distinctUntilChanged filters out successive repetitive values.</p>
		<pre>
			seq([1,,,1,,,3,,,3,,,5,,,1,,,]).distinctUntilChanged() ===
			seq([1,,,,,,,3,,,,,,,5,,,1,,,]);
		</pre>

		<textarea class="code" rows="60" cols="80">
			function (keyPresses, isAlpha) {

				return keyPresses.
					map(function (e) { return String.fromCharCode(e.keyCode); }).

					// Ensure we only have alphabetic characters
					filter(function (character) { return isAlpha(character); }).

					// TODO: Filter out successive repetitive keys

					// Building up a string of all the characters typed.
					scan('', function (stringSoFar, character) {
						return stringSoFar + character;
					});
			}
		</textarea>

		<button class="go">运行</button>

		<label for="inputName">Enter Keys</label>
		<input type="text" class="inputName">

		<div>Keys filtered by distinctUntilChanged</div>
		<div class="filteredKeysByDistinct"></div>

		<button class="showAnswer">显示答案</button>

        <pre class="verifier">
			function(str, lesson) {
				preVerifierHook();
				var $inputName = $('.inputName', lesson),
					$filtered = $('.filteredKeysByDistinct', lesson);

				var keyups = Rx.Observable.fromEvent($inputName[0], 'keyup');

				var isAlpha = function (x) {
					return 'abcdefghijklmnopqrstuvwxyz'.indexOf(x.toLowerCase()) !== -1;
				};

				var code =  eval("(" + str + ")")
				var code = code(keyups, isAlpha);

				code
					.subscribe(function (text) {
						$filtered.text(text);
					});
			}
		</pre>
        <pre class="answer">
			function (keyPresses, isAlpha) {

				return keyPresses.
					map(function (e) { return String.fromCharCode(e.keyCode); }).
					filter(function (character) { return isAlpha(character); }).
					distinctUntilChanged().
					scan('', function (stringSoFar, character) {
						return stringSoFar + character;
					});
			}
        </pre>
		<div class="post">
			<p>Now that we know how to get only the distinct input, let's see how it applies to our autocomplete example...</p>

			<h1>A Work in Progress</h1>

			<p>Congratulations! You've made it this far, but you're not done. Learning is an on-going process. Go out and start
				using the functions you've learned in your day-to-day coding. Over time, I'll be adding more exercises to this
				tutorial. If you have suggestions for more exercises, send me a pull request!
			</p>
		</div>
	</div>
    <div class="modal hide" id="modalGetJSON">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                            aria-hidden="true">&times;</span></button>
                    <h4 class="modal-title">Enter your answer JSON below</h4>
                </div>
                <div class="modal-body">
                    <form>
                        <textarea name="answerText" has-value="true" style="margin: 0px 0px 10px; height: 165px; width: 526px;resize: none"></textarea>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary save-btn" data-dismiss="modal">Save changes</button>
                </div>
            </div>
            <!-- /.modal-content -->
        </div>
        <!-- /.modal-dialog -->
    </div>
	<div class="modal hide" id="modalShowJSON">
		<div class="modal-dialog">
			<div class="modal-content">
				<div class="modal-header">
					<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
							aria-hidden="true">&times;</span></button>
					<h4 class="modal-title">Ctrl-C your answer JSON below</h4>
				</div>
				<div class="modal-body">
					<form>
						<textarea name="answerText" readonly="readonly" has-value="true" style="margin: 0px 0px 10px; height: 165px; width: 526px;resize: none"></textarea>
					</form>
				</div>
				<div class="modal-footer">
					<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
				</div>
			</div>
			<!-- /.modal-content -->
		</div>
		<!-- /.modal-dialog -->
	</div>
</div>

<script src="assets/app/wordlist.js"></script>
<script src="assets/codemirror/codemirror.js"></script>
<script src="assets/app/javascript.js"></script>

<script src="assets/rx/rx.all.js"></script>

<script src="assets/jquery/jquery-1.10.2.min.js"></script>
<script src="assets/bootstrap/js/bootstrap.min.js"></script>
<script src="assets/app/grab_answers.js"></script>
<script src="assets/app/show_answers.js"></script>

<script src="assets/app/utils.js"></script>
<script src="assets/app/main.js"></script>
<script type="text/javascript">

	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-37739914-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script');
		ga.type = 'text/javascript';
		ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(ga, s);
	})();

</script>
</body>
</html>
